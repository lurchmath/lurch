{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This project has moved! \u27a1\ufe0f Visit the new website here. \u2b05\ufe0f","title":"Home"},{"location":"#this-project-has-moved","text":"","title":"This project has moved!"},{"location":"#visit-the-new-website-here","text":"","title":"\u27a1\ufe0f Visit the new website here. \u2b05\ufe0f"},{"location":"bugs-and-enhancements/","text":"Bug fixes and Enhancements This document lists known bugs that we plan to fix and planned enhancements not yet made. They are listed in this file, rather than in the Project Plan because these are things that are not part of the linear progression of the project, in the sense that further work can be done on the main project plan without these bug fixes or enhancements. Bug fixes Overall Arrows representing connections between groups don't look good sometimes. Improve the heuristics for drawing them as follows. The default path is (a) up from the source until it reaches a distance of h above the target's top (for some fixed constant h), (b) turn NE/NW toward the target with radius r, (c) horizontally toward the target, (d) turn SE/SW toward the target with radius r, then (e) down to the target with an arrowhead. One problem with that strategy is that if there is little or no horizontal separation, then it is (close to) just one vertical line. So if the horizontal separation is under 2r, make the following change. The end of the curve can still be a turn SW of radius r, followed by a step down with an arrowhead. But from the source until that point should be a single B\u00e9zier curve that begins with velocity N and ends with velocity W. The other problem with the strategy is if there are many targets in the same row of text, then the lines on the way to those targets will all overlap, and thus become indistinguishable. To solve this, let h be a function equal to $C + 0.03\\Delta x$, where $C$ is some constant and $\\Delta x$ is the horizontal distance between source and target bubbles. The $0.03$ is an estimate that can be customized with testing. Load and save Not all edits cause the document to be marked dirty. TinyMCE events are not firing correctly. Minimal working example created. Or see this related issue. Use the responses from that to get this problem fixed in Lurch, either by updating to a fixed version of TinyMCE or by installing a workaround here. Although you've heard about the KeyUp and SetContent events that you're using in the Groups package, so you may be able to correct this problem partially with those events. (Verified on 9/22/16 that these bugs are still unresolved.) The bug just mentioned has since been closed, and suggests that it may have been fixed in TinyMCE 4.x; check to see. Enhancements MathQuill parsing Before doing any MathQuill updates, import MathQuill 0.10, which has big breaking API changes, and update all Lurch MathQuill calls to use the new API. See here for migration notes. Because that is a major change to many parts of Lurch, test thoroughly, including parsing MathQuill content. Support adjacent atomics as factors in a product Support chained equations Add tests for things that should not parse, and verify that they do not Dependencies Right now circular dependency relationships never cause an infinite loop because dependency content is only embedded when a document is opened. So if A depends on B which depends on A, then when A is opened, it will embed B, which indirectly embeds the saved version of A. If A is saved and B is opened, that will embed the (new, larger) A, and this can continue to increase file sizes as we repeatedly open documents. But each step of this infinite expansion requires a user action, so the application will never hang. However, it can be a silent and highly undesirable file inflater. Expand the dependency loading mechanism to check for a loop by finding the same filename or wiki URL nested within itself in the dependency data of a document, and alert the user. Extend the \"Add URL dependency\" event handler with a \"please wait\" indicator while the document is being fetched. Use the waiting method in the Dialogs plugin. There is not yet support for adding dependencies from files in your Dropbox. Add this feature. Cheat sheets The \"Cheatsheets\" menu item of the RStudio GUI is an excellent resource for many users. It contains links to online PDFs of one- or two-sided printable, dense reference sheets for common topics in RStudio. A similar cheatsheet (or set thereof) could be created about Lurch. Consider these topics. The advanced users guide, condensed into a two-sided reference Understanding and dealing with validation messages A reference for each of the built-in libraries Groups Plugin Make a menu item for hiding/showing group decorations. The Group.set function no longer takes any action if the new value is the same as the old value. (Similarly, clear doesn't do anything if the attribute is already gone.) This prevents clients from needing to implement their own checks to prevent infinite loops of change event handlers. The remaining task is to go through the demo apps and find their workarounds for this annoyance and remove them to clean up those apps (and not confuse readers). Then verify that the apps still work, i.e., that there truly are no infinite loops remaining. Several new methods have been added to the Groups Plugin without unit tests being written for them. Be sure to look back through the full list of functions in that file and find those which have no unit tests, and create unit tests for them, debugging the functions as you do so. The following new members will be needed in the Group class as we create more complex webLurch-based applications saveCursorPosition() , which returns a bookmark restoreCursorPosition() , which returns to a bookmark you provide allContents() , which returns an array of alternating strings and groups UI for Connections Between Groups Add a keyboard shortcut for entering connection mode (that is, clicking the connection button on the toolbar). This should be in the groups plugin. Add a keyboard shortcut for cycling through the built-in keys an attribute expression can have. This should be in the main Lurch app. Add an option that when entering arrow-creation mode, ALL bubble outlines in the document are faintly drawn (not their tags), so that it's completely clear where a user wants to aim the mouse to hit a certain bubble. Add an option that show-groupers (Ctrl/Cmd+1) mode is automatically enabled when the user enters arrow-connection mode, and re-disabled (if it was disabled in the first place) when exiting arrow-connection mode. This is like the previous feature, but more aggressive and techy. (Do we still need it now that we have the previous feature?) On mobile, a tap highlights the innermost bubble under it, without creating the arrow yet, and shows OK/cancel buttons hovering nearby. If the user tapped what he/she expected to tap, then he/she hits OK and it creates the arrow. Cancel (or just tapping elsewhere) closes the OK/cancel buttons and does nothing else. When in arrow-creation mode, keystrokes are interpreted as typing bubble labels, which will scroll the view to the bubbles with those labels, and highlight them as if the user had mouse-hovered them. If the user presses enter, the arrow will be created. Hence there are keyboard-shortcut ways to specify arrows among bubbles. This would work best with a keyboard shortcut for entering bubble-making mode also. (If there are ambiguous labels--i.e., ones that apply to more than one bubble--just choose any one; that's the user's fault.) Note that this requires two additional features to help it out: A function in the group type for computing the default label for any bubble in the document. The default can be the address of the bubble in the hierarchy, as a list of positive integers; e.g., the second bubble immediate inside the tenth topmost bubble has number 10.2. Drawing bubbles in arrow-creation mode should include these labels somewhere nearby. Miscellaneous See this answer to your StackOverflow question about higher resolution HTML canvas rendering on retina deisplays. See if its suggestions can work in your case. This may be the same as the following one... Bubble tags are not drawn at retina resolution on Macs with retina displays. See my question about how to fix this problem here. Complete the unit test for the DOM Utils package . See the end of that file for the few missing tests. If you ever need to export PDFs of Lurch documents, consider jsPDF .","title":"Bug fix/enhancement list"},{"location":"bugs-and-enhancements/#bug-fixes-and-enhancements","text":"This document lists known bugs that we plan to fix and planned enhancements not yet made. They are listed in this file, rather than in the Project Plan because these are things that are not part of the linear progression of the project, in the sense that further work can be done on the main project plan without these bug fixes or enhancements.","title":"Bug fixes and Enhancements"},{"location":"bugs-and-enhancements/#bug-fixes","text":"","title":"Bug fixes"},{"location":"bugs-and-enhancements/#overall","text":"Arrows representing connections between groups don't look good sometimes. Improve the heuristics for drawing them as follows. The default path is (a) up from the source until it reaches a distance of h above the target's top (for some fixed constant h), (b) turn NE/NW toward the target with radius r, (c) horizontally toward the target, (d) turn SE/SW toward the target with radius r, then (e) down to the target with an arrowhead. One problem with that strategy is that if there is little or no horizontal separation, then it is (close to) just one vertical line. So if the horizontal separation is under 2r, make the following change. The end of the curve can still be a turn SW of radius r, followed by a step down with an arrowhead. But from the source until that point should be a single B\u00e9zier curve that begins with velocity N and ends with velocity W. The other problem with the strategy is if there are many targets in the same row of text, then the lines on the way to those targets will all overlap, and thus become indistinguishable. To solve this, let h be a function equal to $C + 0.03\\Delta x$, where $C$ is some constant and $\\Delta x$ is the horizontal distance between source and target bubbles. The $0.03$ is an estimate that can be customized with testing.","title":"Overall"},{"location":"bugs-and-enhancements/#load-and-save","text":"Not all edits cause the document to be marked dirty. TinyMCE events are not firing correctly. Minimal working example created. Or see this related issue. Use the responses from that to get this problem fixed in Lurch, either by updating to a fixed version of TinyMCE or by installing a workaround here. Although you've heard about the KeyUp and SetContent events that you're using in the Groups package, so you may be able to correct this problem partially with those events. (Verified on 9/22/16 that these bugs are still unresolved.) The bug just mentioned has since been closed, and suggests that it may have been fixed in TinyMCE 4.x; check to see.","title":"Load and save"},{"location":"bugs-and-enhancements/#enhancements","text":"","title":"Enhancements"},{"location":"bugs-and-enhancements/#mathquill-parsing","text":"Before doing any MathQuill updates, import MathQuill 0.10, which has big breaking API changes, and update all Lurch MathQuill calls to use the new API. See here for migration notes. Because that is a major change to many parts of Lurch, test thoroughly, including parsing MathQuill content. Support adjacent atomics as factors in a product Support chained equations Add tests for things that should not parse, and verify that they do not","title":"MathQuill parsing"},{"location":"bugs-and-enhancements/#dependencies","text":"Right now circular dependency relationships never cause an infinite loop because dependency content is only embedded when a document is opened. So if A depends on B which depends on A, then when A is opened, it will embed B, which indirectly embeds the saved version of A. If A is saved and B is opened, that will embed the (new, larger) A, and this can continue to increase file sizes as we repeatedly open documents. But each step of this infinite expansion requires a user action, so the application will never hang. However, it can be a silent and highly undesirable file inflater. Expand the dependency loading mechanism to check for a loop by finding the same filename or wiki URL nested within itself in the dependency data of a document, and alert the user. Extend the \"Add URL dependency\" event handler with a \"please wait\" indicator while the document is being fetched. Use the waiting method in the Dialogs plugin. There is not yet support for adding dependencies from files in your Dropbox. Add this feature.","title":"Dependencies"},{"location":"bugs-and-enhancements/#cheat-sheets","text":"The \"Cheatsheets\" menu item of the RStudio GUI is an excellent resource for many users. It contains links to online PDFs of one- or two-sided printable, dense reference sheets for common topics in RStudio. A similar cheatsheet (or set thereof) could be created about Lurch. Consider these topics. The advanced users guide, condensed into a two-sided reference Understanding and dealing with validation messages A reference for each of the built-in libraries","title":"Cheat sheets"},{"location":"bugs-and-enhancements/#groups-plugin","text":"Make a menu item for hiding/showing group decorations. The Group.set function no longer takes any action if the new value is the same as the old value. (Similarly, clear doesn't do anything if the attribute is already gone.) This prevents clients from needing to implement their own checks to prevent infinite loops of change event handlers. The remaining task is to go through the demo apps and find their workarounds for this annoyance and remove them to clean up those apps (and not confuse readers). Then verify that the apps still work, i.e., that there truly are no infinite loops remaining. Several new methods have been added to the Groups Plugin without unit tests being written for them. Be sure to look back through the full list of functions in that file and find those which have no unit tests, and create unit tests for them, debugging the functions as you do so. The following new members will be needed in the Group class as we create more complex webLurch-based applications saveCursorPosition() , which returns a bookmark restoreCursorPosition() , which returns to a bookmark you provide allContents() , which returns an array of alternating strings and groups","title":"Groups Plugin"},{"location":"bugs-and-enhancements/#ui-for-connections-between-groups","text":"Add a keyboard shortcut for entering connection mode (that is, clicking the connection button on the toolbar). This should be in the groups plugin. Add a keyboard shortcut for cycling through the built-in keys an attribute expression can have. This should be in the main Lurch app. Add an option that when entering arrow-creation mode, ALL bubble outlines in the document are faintly drawn (not their tags), so that it's completely clear where a user wants to aim the mouse to hit a certain bubble. Add an option that show-groupers (Ctrl/Cmd+1) mode is automatically enabled when the user enters arrow-connection mode, and re-disabled (if it was disabled in the first place) when exiting arrow-connection mode. This is like the previous feature, but more aggressive and techy. (Do we still need it now that we have the previous feature?) On mobile, a tap highlights the innermost bubble under it, without creating the arrow yet, and shows OK/cancel buttons hovering nearby. If the user tapped what he/she expected to tap, then he/she hits OK and it creates the arrow. Cancel (or just tapping elsewhere) closes the OK/cancel buttons and does nothing else. When in arrow-creation mode, keystrokes are interpreted as typing bubble labels, which will scroll the view to the bubbles with those labels, and highlight them as if the user had mouse-hovered them. If the user presses enter, the arrow will be created. Hence there are keyboard-shortcut ways to specify arrows among bubbles. This would work best with a keyboard shortcut for entering bubble-making mode also. (If there are ambiguous labels--i.e., ones that apply to more than one bubble--just choose any one; that's the user's fault.) Note that this requires two additional features to help it out: A function in the group type for computing the default label for any bubble in the document. The default can be the address of the bubble in the hierarchy, as a list of positive integers; e.g., the second bubble immediate inside the tenth topmost bubble has number 10.2. Drawing bubbles in arrow-creation mode should include these labels somewhere nearby.","title":"UI for Connections Between Groups"},{"location":"bugs-and-enhancements/#miscellaneous","text":"See this answer to your StackOverflow question about higher resolution HTML canvas rendering on retina deisplays. See if its suggestions can work in your case. This may be the same as the following one... Bubble tags are not drawn at retina resolution on Macs with retina displays. See my question about how to fix this problem here. Complete the unit test for the DOM Utils package . See the end of that file for the few missing tests. If you ever need to export PDFs of Lurch documents, consider jsPDF .","title":"Miscellaneous"},{"location":"code-demo-app-plan/","text":"Plan for a code-related demo app This document is the specifications and development for a demo app built on the Lurch Web Platform. The app will be a prototype of an idea for how code can be written in natural language using the groups-and-connections UI that we use in webLurch for proofs. The app will be divided by a vertical splitter into two panes, the left of which will be the standard webLurch UI, and the right of which will be code generated from the document's meaning. The code for this demo app is here . Suggestions This is not yet planned, but the \"suggestions\" feature that exists in the main app would make a nice showcase feature in this app as well. Refactoring forms On the context menu for groups will be an item \"Rephrase...\" Clicking it opens a dialog in which the user can browse through all the structure translators that apply to the code form represented by the group, and choose one (or cancel). If the user chooses one, the content of the group in the document is rewritten to match the output of the translator. No interior groups are destroyed, only moved. Editing a group by hand (the text immediately inside a group) marks it dirty, so that the \"rephrase\" action will first warn you that if you accept the changes, you'll be throwing away your manual edits. Low priority If there is a selection when the user attempts to insert a group, and it contains text only with zero or more entire groups among the text, but no partial groups, and the selection is not exactly equal to the content of an existing group, then the boilerplate code is inserted at the cursor point, and (a) if the boiler-plate code has no inner groups, all of its inner text is replaced by the content of the selection, but (b) if it does have inner groups, then the first one's content is replaced by the content of the selection. If there is a selection when the user attempts to insert a group, and that selection is exactly the extent of an existing group, a modal dialog will ask if the user wishes to (a) wrap the existing group in the new group, (b) insert the new group inside the existing one, or (c) change the existing group into the new type. If there is a selection when the user attempts to insert a group, and none of the above criteria apply, let the user know that they cannot insert a new group in that situation.","title":"Plan for a code-related demo app"},{"location":"code-demo-app-plan/#plan-for-a-code-related-demo-app","text":"This document is the specifications and development for a demo app built on the Lurch Web Platform. The app will be a prototype of an idea for how code can be written in natural language using the groups-and-connections UI that we use in webLurch for proofs. The app will be divided by a vertical splitter into two panes, the left of which will be the standard webLurch UI, and the right of which will be code generated from the document's meaning. The code for this demo app is here .","title":"Plan for a code-related demo app"},{"location":"code-demo-app-plan/#suggestions","text":"This is not yet planned, but the \"suggestions\" feature that exists in the main app would make a nice showcase feature in this app as well.","title":"Suggestions"},{"location":"code-demo-app-plan/#refactoring-forms","text":"On the context menu for groups will be an item \"Rephrase...\" Clicking it opens a dialog in which the user can browse through all the structure translators that apply to the code form represented by the group, and choose one (or cancel). If the user chooses one, the content of the group in the document is rewritten to match the output of the translator. No interior groups are destroyed, only moved. Editing a group by hand (the text immediately inside a group) marks it dirty, so that the \"rephrase\" action will first warn you that if you accept the changes, you'll be throwing away your manual edits.","title":"Refactoring forms"},{"location":"code-demo-app-plan/#low-priority","text":"If there is a selection when the user attempts to insert a group, and it contains text only with zero or more entire groups among the text, but no partial groups, and the selection is not exactly equal to the content of an existing group, then the boilerplate code is inserted at the cursor point, and (a) if the boiler-plate code has no inner groups, all of its inner text is replaced by the content of the selection, but (b) if it does have inner groups, then the first one's content is replaced by the content of the selection. If there is a selection when the user attempts to insert a group, and that selection is exactly the extent of an existing group, a modal dialog will ask if the user wishes to (a) wrap the existing group in the new group, (b) insert the new group inside the existing one, or (c) change the existing group into the new type. If there is a selection when the user attempts to insert a group, and none of the above criteria apply, let the user know that they cannot insert a new group in that situation.","title":"Low priority"},{"location":"dev-tutorial/","text":"Demo Apps and App Developer Tutorial Introduction What can I build with this platform? The webLurch architecture has three tiers: The top tier are the applications, built on the middle tier, which is the Lurch Web Platform , which is built on the bottom tier, the WYSIWYG editor TinyMCE . TinyMCE provides: WYSIWYG editing of HTML content Extendability through custom toolbars, menus, dialogs, etc. The Lurch Web Platform builds on that foundation, and provides: In-cloud and in-browser storage A WYSIWYG math editing widget, imported from here Groups , the most important contribution of the Lurch Web Platform , explained below . Facilities for computing with groups, such as a background computation/parallelization toolkit What are groups? The crux of the user interface for the desktop version of Lurch is the ability for the user to mark portions of a document as meaningful with groups. Groups are represented on screen as \"bubbles,\" as in the images below. Thus the terms \"group\" and \"bubble\" are sometimes used interchangeably, but technically \"group\" is the term for the object in memory, and \"bubble\" its representation on screen. Examples: One demo app lets users wrap bubbles around mathematical expressions to tell Lurch to pay attention to the expressions' meaning. Lurch puts a tag above the bubble to let the user see what the content means to Lurch. Another demo app lets users put bubbles around text to give it application-specific meaning. The following screenshot is from an application for authoring OpenMath Content Dictionaries. Complex nested group hierarchies are possible and very useful. Desktop Lurch uses them constantly: Read about about the importance of this user interface paradigm in a blog post about the desktop version of Lurch. Example Applications There are six example applications built on this platform, each covered on the example applications page . Tutorial Build a Lurch Web Application as follows. Phase 1: Create a web page that imports the Lurch Web Platform . Phase 2: Write code that defines a set of group types. Phase 3: Optionally add new/custom behaviors to those types. This section gives step-by-step instructions for creating your own Lurch Web Application. By the end of this section, you will have completed Phases 1 and 2 on the list, and will know where to go to explore Phase 3. Phase 1: A first app (and a very simple one) The easiest way to begin is with a working app. Get a copy of the simple example app as follows: Visit that page and use the green button to download a .zip of that repository to your computer. Extract its contents. Run npm install in that folder, then run gulp and be sure that it can rebuild the app successfully. Start up a simple web server in that folder to serve yourself that app so that we can be sure it's working: python -m SimpleHTTPServer 8000 Visit http://localhost:8000 to see the simple example app running on your machine. Edit lwp-example-simple.litcoffee . The file begins with a lot of documentation, and then the first line of code is setAppName 'ExampleApp' . Change the contents of the string to your app's name. Rebuild using gulp and revisit the page to ensure that the app name in the browser's tab has changed to your app's name. You've created a (very simple) app! And you know how to change your app's code, rebuild, and visit your updated app. So what kinds of code changes are possible? Let's see. Phase 2: Changing or adding group types The individual bubbles you can add to the document in the example app are the visual representation of what, under the hood, are called \"groups.\" Each app has a different set of group types that the user may insert in the document, depending on the needs of the application. Examples: In the simple app you have, there is only one group type, and it does very litte: It reports the size of its contents and dumps some debugging information to the browser console. The complex demo app defines two group types, one for wrapping and evaluating expressions of arithmetic and another for wrapping and doing simple computations on words. The math demo app has nly one group type, for parsing and evaluating mathematical expressions. The OpenMath Content Dictionary Editor has only one group type, but it can have any of over a dozen different purposes, editable using the context menu on each individual group. If we look at the code in your app that defines group types, stripping away all the documentation, it looks like the following. window.groupTypes = [ name : 'reporter' text : 'Simple Event Reporter' imageHTML : '[ ]' openImageHTML : '[' closeImageHTML : ']' tagContents : ( group ) -> \"#{group.contentAsText()?.length} characters\" contentsChanged : ( group, firstTime ) -> console.log 'This group just changed:', group.contentAsText() ] All of this is fully documented in the original file , so I do not repeat here what any of it means. But note that this is simply the assignment to a global variable of an array of group type data. You could extend it to add another group type as follows. window.groupTypes = [ # # This code is the same as before: # name : 'reporter' text : 'Simple Event Reporter' imageHTML : '[ ]' openImageHTML : '[' closeImageHTML : ']' tagContents : ( group ) -> \"#{group.contentAsText()?.length} characters\" contentsChanged : ( group, firstTime ) -> console.log 'This group just changed:', group.contentAsText() # # Here begins the new code: # , name : 'myNewGroupType' text : 'My New Group Type' imageHTML : '{}' openImageHTML : '{' closeImageHTML : '}' tagContents : ( group ) -> 'every tag has this content' # no event handler for changes to group contents ] Rebuilding your app and reloading it in the browser should then let you insert either of the two kinds of groups. Each type should have its own button on the toolbar. By simply extending the list above, you can define any set of group types you see fit in your application. Note that the open and close HTML can be arbitrary HTML, including (small) images, font colors, and styles. The only question that remains is how to make your groups do something useful. Phase 3: Adding interactivity to your groups What else can groups do? Here are many examples, each with a link to where you can read more information and see example code. Report information about the group on the bubble's tag Every example app you've seen so far does this. Simply search the source code repository for the tagContents function and look at the variety of implementations. In computing the contents of the tag, you will want to be able to query information about your group, such as its text content, or whether it has any groups inside of it. The API for a Group object is documented in the source code for the Groups Plugin . Customize a group's color Include among the key-value pairs in your group type definition a pair like color : '#aacc00' , or whatever HTML color you choose. Store and retrieve custom data in a Group object In the API linked to immediately above, see the set , get , and clear functions in the Group class. These store arbitrary JSON data under string keys in a group. It is very common to do a computation and store its result in an attribute of the group, the read that later when computing the contents of the group's tag, thus giving the user feedback on the results of some background process. Find what groups are in the document For a complete answer, see the API for the Groups class (different from the Group class!) in the Groups Plugin . Since that file is large, I give highlights here. Access the one, global Groups object using the code tinymce.activeEditor.Groups . I call this object Groups hereafter. Get the array of all group IDs in your document (in the order their open boundaries appear in the document) with Groups.ids() . Get a group object from its ID by indexing Groups as if it were an array, as in Groups[someID] or Groups[0] . For any group G , get the group containing it with G.parent , which will be null if the group is top-level in the document, or if it was just created in the document (instants ago) and the editor has therefore not yet had a chance to re-scan and assign parent/child relationships. For any group G , get an ordered array of the groups it (immediately) contains with G.children . (Same caveat about just-created groups applies here.) Pushing complex computations into the background The Lurch Web Platform provides functionality for moving arbitrary computations into one or more background threads, with parallelization managed efficiently for you. This lengthy topic is covered in two files: The \"complex example\" demo app pushes some computations into the background, and you can follow its example code. The background module documents the full API that's being leveraged by that demo app. Extending the menus that appear when users right-click a group or click its bubble tag Extending a group's context menu is done by providing a contextMenuItems function in the group type definition. For an example, look for that term in the source code for the complex example demo app . Extending a group's tag menu is done by providing a tagMenuItems function that behaves exactly the same way, but may choose to return a different list of menu items. Adding new buttons to the editor toolbar This is done by assigning to the global object window.groupToolbarButtons . See an example here. Adding new menu items to the editor's menus This is done by assigning to the global object window.groupMenuItems . There is not an example of this at the moment, but it functions very similar to the previous bullet point, about toolbar buttons. The implementation appears in the main setup code . Showing dialog boxes TinyMCE provides a few ways to show dialog boxes containing plain text . If your dialog box must contain more than just plain text, see the Dialogs plugin . Adding decorations to group boundaries It is common to give feedback to the user about the content of a group in a more obvious way than the bubble tag (which is only visible when the user's cursor is in the group). For instance, if there is an error in what the user has entered in a group, you might want to flag it in an obvious way, as the \u2716 does in the following example from the OpenMath Content Dictionary Editor demo app . This is a special case of \"decorating\" a group. To add decorations to a group G , you have the following API. G.set 'openDecoration', 'any valid HTML here' - sets the decoration that will appear to the left of its open boundary marker (not used in the image above) G.set 'closeDecoration', 'any valid HTML here' - same as the previous but for after the close boundary marker (as in the image above) G.clear 'openDecoration' and G.clear 'closeDecoration' behave as expected Note that there are many useful Unicode characters for visually giving understandable feedback concisely. Consider the following, each of which can be made more informative by wrapping it in <font color=\"red\">...</font> , as in the image above, or some other color suiting your application. X's &#10006; is \u2716 &#10007; is \u2717 &#10007; is \u2718 Checks &#10003; is \u2713 &#10004; is \u2714 Stars &#10029; is \u272d &#10038; is \u2736 &#10039; is \u2737 &#10040; is \u2738 &#10041; is \u2739 Numbers &#10122; is \u278a ... in order through ... &#10131; is \u2793 Other functionality In this section I document other configuration possibilities beyond those mentioned above, things that didn't fit neatly into the above categories. To run any code after the editor has been set up, assign a function to the global variable window.afterEditorReady . Your function should accept a single parameter, editor , which will be the editor object that was just initialized. Your function will be called at the end of the TinyMCE editor \"init\" event. This tutorial was written by Nathan Carter . Feel free to contact me with questions. I would love to know how we can help get you started coding on the Lurch Web Platform .","title":"Tutorial"},{"location":"dev-tutorial/#demo-apps-and-app-developer-tutorial","text":"","title":"Demo Apps and App Developer Tutorial"},{"location":"dev-tutorial/#introduction","text":"","title":"Introduction"},{"location":"dev-tutorial/#what-can-i-build-with-this-platform","text":"The webLurch architecture has three tiers: The top tier are the applications, built on the middle tier, which is the Lurch Web Platform , which is built on the bottom tier, the WYSIWYG editor TinyMCE . TinyMCE provides: WYSIWYG editing of HTML content Extendability through custom toolbars, menus, dialogs, etc. The Lurch Web Platform builds on that foundation, and provides: In-cloud and in-browser storage A WYSIWYG math editing widget, imported from here Groups , the most important contribution of the Lurch Web Platform , explained below . Facilities for computing with groups, such as a background computation/parallelization toolkit","title":"What can I build with this platform?"},{"location":"dev-tutorial/#what-are-groups","text":"The crux of the user interface for the desktop version of Lurch is the ability for the user to mark portions of a document as meaningful with groups. Groups are represented on screen as \"bubbles,\" as in the images below. Thus the terms \"group\" and \"bubble\" are sometimes used interchangeably, but technically \"group\" is the term for the object in memory, and \"bubble\" its representation on screen. Examples: One demo app lets users wrap bubbles around mathematical expressions to tell Lurch to pay attention to the expressions' meaning. Lurch puts a tag above the bubble to let the user see what the content means to Lurch. Another demo app lets users put bubbles around text to give it application-specific meaning. The following screenshot is from an application for authoring OpenMath Content Dictionaries. Complex nested group hierarchies are possible and very useful. Desktop Lurch uses them constantly: Read about about the importance of this user interface paradigm in a blog post about the desktop version of Lurch.","title":"What are groups?"},{"location":"dev-tutorial/#example-applications","text":"There are six example applications built on this platform, each covered on the example applications page .","title":"Example Applications"},{"location":"dev-tutorial/#tutorial","text":"Build a Lurch Web Application as follows. Phase 1: Create a web page that imports the Lurch Web Platform . Phase 2: Write code that defines a set of group types. Phase 3: Optionally add new/custom behaviors to those types. This section gives step-by-step instructions for creating your own Lurch Web Application. By the end of this section, you will have completed Phases 1 and 2 on the list, and will know where to go to explore Phase 3.","title":"Tutorial"},{"location":"dev-tutorial/#phase-1-a-first-app-and-a-very-simple-one","text":"The easiest way to begin is with a working app. Get a copy of the simple example app as follows: Visit that page and use the green button to download a .zip of that repository to your computer. Extract its contents. Run npm install in that folder, then run gulp and be sure that it can rebuild the app successfully. Start up a simple web server in that folder to serve yourself that app so that we can be sure it's working: python -m SimpleHTTPServer 8000 Visit http://localhost:8000 to see the simple example app running on your machine. Edit lwp-example-simple.litcoffee . The file begins with a lot of documentation, and then the first line of code is setAppName 'ExampleApp' . Change the contents of the string to your app's name. Rebuild using gulp and revisit the page to ensure that the app name in the browser's tab has changed to your app's name. You've created a (very simple) app! And you know how to change your app's code, rebuild, and visit your updated app. So what kinds of code changes are possible? Let's see.","title":"Phase 1: A first app (and a very simple one)"},{"location":"dev-tutorial/#phase-2-changing-or-adding-group-types","text":"The individual bubbles you can add to the document in the example app are the visual representation of what, under the hood, are called \"groups.\" Each app has a different set of group types that the user may insert in the document, depending on the needs of the application. Examples: In the simple app you have, there is only one group type, and it does very litte: It reports the size of its contents and dumps some debugging information to the browser console. The complex demo app defines two group types, one for wrapping and evaluating expressions of arithmetic and another for wrapping and doing simple computations on words. The math demo app has nly one group type, for parsing and evaluating mathematical expressions. The OpenMath Content Dictionary Editor has only one group type, but it can have any of over a dozen different purposes, editable using the context menu on each individual group. If we look at the code in your app that defines group types, stripping away all the documentation, it looks like the following. window.groupTypes = [ name : 'reporter' text : 'Simple Event Reporter' imageHTML : '[ ]' openImageHTML : '[' closeImageHTML : ']' tagContents : ( group ) -> \"#{group.contentAsText()?.length} characters\" contentsChanged : ( group, firstTime ) -> console.log 'This group just changed:', group.contentAsText() ] All of this is fully documented in the original file , so I do not repeat here what any of it means. But note that this is simply the assignment to a global variable of an array of group type data. You could extend it to add another group type as follows. window.groupTypes = [ # # This code is the same as before: # name : 'reporter' text : 'Simple Event Reporter' imageHTML : '[ ]' openImageHTML : '[' closeImageHTML : ']' tagContents : ( group ) -> \"#{group.contentAsText()?.length} characters\" contentsChanged : ( group, firstTime ) -> console.log 'This group just changed:', group.contentAsText() # # Here begins the new code: # , name : 'myNewGroupType' text : 'My New Group Type' imageHTML : '{}' openImageHTML : '{' closeImageHTML : '}' tagContents : ( group ) -> 'every tag has this content' # no event handler for changes to group contents ] Rebuilding your app and reloading it in the browser should then let you insert either of the two kinds of groups. Each type should have its own button on the toolbar. By simply extending the list above, you can define any set of group types you see fit in your application. Note that the open and close HTML can be arbitrary HTML, including (small) images, font colors, and styles. The only question that remains is how to make your groups do something useful.","title":"Phase 2: Changing or adding group types"},{"location":"dev-tutorial/#phase-3-adding-interactivity-to-your-groups","text":"What else can groups do? Here are many examples, each with a link to where you can read more information and see example code. Report information about the group on the bubble's tag Every example app you've seen so far does this. Simply search the source code repository for the tagContents function and look at the variety of implementations. In computing the contents of the tag, you will want to be able to query information about your group, such as its text content, or whether it has any groups inside of it. The API for a Group object is documented in the source code for the Groups Plugin . Customize a group's color Include among the key-value pairs in your group type definition a pair like color : '#aacc00' , or whatever HTML color you choose. Store and retrieve custom data in a Group object In the API linked to immediately above, see the set , get , and clear functions in the Group class. These store arbitrary JSON data under string keys in a group. It is very common to do a computation and store its result in an attribute of the group, the read that later when computing the contents of the group's tag, thus giving the user feedback on the results of some background process. Find what groups are in the document For a complete answer, see the API for the Groups class (different from the Group class!) in the Groups Plugin . Since that file is large, I give highlights here. Access the one, global Groups object using the code tinymce.activeEditor.Groups . I call this object Groups hereafter. Get the array of all group IDs in your document (in the order their open boundaries appear in the document) with Groups.ids() . Get a group object from its ID by indexing Groups as if it were an array, as in Groups[someID] or Groups[0] . For any group G , get the group containing it with G.parent , which will be null if the group is top-level in the document, or if it was just created in the document (instants ago) and the editor has therefore not yet had a chance to re-scan and assign parent/child relationships. For any group G , get an ordered array of the groups it (immediately) contains with G.children . (Same caveat about just-created groups applies here.) Pushing complex computations into the background The Lurch Web Platform provides functionality for moving arbitrary computations into one or more background threads, with parallelization managed efficiently for you. This lengthy topic is covered in two files: The \"complex example\" demo app pushes some computations into the background, and you can follow its example code. The background module documents the full API that's being leveraged by that demo app. Extending the menus that appear when users right-click a group or click its bubble tag Extending a group's context menu is done by providing a contextMenuItems function in the group type definition. For an example, look for that term in the source code for the complex example demo app . Extending a group's tag menu is done by providing a tagMenuItems function that behaves exactly the same way, but may choose to return a different list of menu items. Adding new buttons to the editor toolbar This is done by assigning to the global object window.groupToolbarButtons . See an example here. Adding new menu items to the editor's menus This is done by assigning to the global object window.groupMenuItems . There is not an example of this at the moment, but it functions very similar to the previous bullet point, about toolbar buttons. The implementation appears in the main setup code . Showing dialog boxes TinyMCE provides a few ways to show dialog boxes containing plain text . If your dialog box must contain more than just plain text, see the Dialogs plugin . Adding decorations to group boundaries It is common to give feedback to the user about the content of a group in a more obvious way than the bubble tag (which is only visible when the user's cursor is in the group). For instance, if there is an error in what the user has entered in a group, you might want to flag it in an obvious way, as the \u2716 does in the following example from the OpenMath Content Dictionary Editor demo app . This is a special case of \"decorating\" a group. To add decorations to a group G , you have the following API. G.set 'openDecoration', 'any valid HTML here' - sets the decoration that will appear to the left of its open boundary marker (not used in the image above) G.set 'closeDecoration', 'any valid HTML here' - same as the previous but for after the close boundary marker (as in the image above) G.clear 'openDecoration' and G.clear 'closeDecoration' behave as expected Note that there are many useful Unicode characters for visually giving understandable feedback concisely. Consider the following, each of which can be made more informative by wrapping it in <font color=\"red\">...</font> , as in the image above, or some other color suiting your application. X's &#10006; is \u2716 &#10007; is \u2717 &#10007; is \u2718 Checks &#10003; is \u2713 &#10004; is \u2714 Stars &#10029; is \u272d &#10038; is \u2736 &#10039; is \u2737 &#10040; is \u2738 &#10041; is \u2739 Numbers &#10122; is \u278a ... in order through ... &#10131; is \u2793","title":"Phase 3: Adding interactivity to your groups"},{"location":"dev-tutorial/#other-functionality","text":"In this section I document other configuration possibilities beyond those mentioned above, things that didn't fit neatly into the above categories. To run any code after the editor has been set up, assign a function to the global variable window.afterEditorReady . Your function should accept a single parameter, editor , which will be the editor object that was just initialized. Your function will be called at the end of the TinyMCE editor \"init\" event. This tutorial was written by Nathan Carter . Feel free to contact me with questions. I would love to know how we can help get you started coding on the Lurch Web Platform .","title":"Other functionality"},{"location":"developer/","text":"Lurch Developer Docs A Development Platform Rewriting the Lurch desktop app for the web involves building many supporting tools that we call the Lurch Web Platform. Other developers can build math-enabled web apps on the same platform, which improves the platform and grows the community. We've made the architecture simple and the learning curve small. See the demo applications and tutorial to start developing. We are currently using the platform to build Lurch on the web. Architecture The following table illustrates the software architecture. Read it from the bottom up. Applications: Lurch Proof Checker Demo apps Your app Platform: Lurch Web Platform Foundation: TinyMCE editor Getting involved If you're interested in helping out with development of this project (e.g., upstream commits if you use the platform), contact Nathan Carter . Repository details All source code is in literate CoffeeScript . This makes it highly readable, especially on GitHub, which renders it as MarkDown. I have tried to be verbose in my comments, to help new readers. Repository overview: / (root folder) package.json - used by node.js to install dependencies (The app runs in a browser, not node.js. This is just for dev tools.) gulpfile.litcoffee define the build process, which uses gulp mkdocs.yml defines how this documentation site is built, which uses mkdocs docs All source files (Markdown) for this documentation site, which mkdocs compiles into the site folder. site Compiled version of doc-src/ folder, for hosting on GitHub Pages; you are seeing its contents here on this site source Source code files used for building the platform. The build process compiles these into files in the release folder. unit-tests Unit tests. To run them, execute gulp test in the main folder, after you've set it up as per the Getting Started page . release Demo apps and the plugins that create them reside here. You can try them out live on the web; see the demo apps and tutorials page . The Lurch Proof Checker is being rewritten for the web and it will live in this folder later.","title":"Introduction"},{"location":"developer/#lurch-developer-docs","text":"","title":"Lurch Developer Docs"},{"location":"developer/#a-development-platform","text":"Rewriting the Lurch desktop app for the web involves building many supporting tools that we call the Lurch Web Platform. Other developers can build math-enabled web apps on the same platform, which improves the platform and grows the community. We've made the architecture simple and the learning curve small. See the demo applications and tutorial to start developing. We are currently using the platform to build Lurch on the web.","title":"A Development Platform"},{"location":"developer/#architecture","text":"The following table illustrates the software architecture. Read it from the bottom up. Applications: Lurch Proof Checker Demo apps Your app Platform: Lurch Web Platform Foundation: TinyMCE editor","title":"Architecture"},{"location":"developer/#getting-involved","text":"If you're interested in helping out with development of this project (e.g., upstream commits if you use the platform), contact Nathan Carter .","title":"Getting involved"},{"location":"developer/#repository-details","text":"All source code is in literate CoffeeScript . This makes it highly readable, especially on GitHub, which renders it as MarkDown. I have tried to be verbose in my comments, to help new readers. Repository overview: / (root folder) package.json - used by node.js to install dependencies (The app runs in a browser, not node.js. This is just for dev tools.) gulpfile.litcoffee define the build process, which uses gulp mkdocs.yml defines how this documentation site is built, which uses mkdocs docs All source files (Markdown) for this documentation site, which mkdocs compiles into the site folder. site Compiled version of doc-src/ folder, for hosting on GitHub Pages; you are seeing its contents here on this site source Source code files used for building the platform. The build process compiles these into files in the release folder. unit-tests Unit tests. To run them, execute gulp test in the main folder, after you've set it up as per the Getting Started page . release Demo apps and the plugins that create them reside here. You can try them out live on the web; see the demo apps and tutorials page . The Lurch Proof Checker is being rewritten for the web and it will live in this folder later.","title":"Repository details"},{"location":"embedding/","text":"Embedding Lurch in a website or blog Overview When writing a web page or blog about introductory proofs, or about Lurch itself, authors will want to show examples of small documents in a live Lurch application. Validation will be functioning and showing its results, and users can explore the example interactively as well, possibly even experimenting and/or making changes. We call this embedding Lurch in a web page or blog. How To The author must do three things to embed Lurch in a blog/website: Include jQuery in the page, because the Lurch embedding script in the following bullet point depends upon it. Include this code at the top of your webpage, or in the scripts list for your blog: <script src='http://nathancarter.github.io/weblurch/app/lurch-embed-solo.min.js'></script> Create DIVs (or other blocks) with the class \"lurch-embed\" and place into them your content. You can directly paste content copied directly from the Lurch web app, or you can write in Lurch shorthand . <div class='lurch-embed'> <p>Here is a Lurch document with two paragraphs, but no expressions.</p> <p>To see how to embed expressions, check out the examples below.</p> </div> Examples Embedding a very tiny Lurch document into a webpage by pasting raw Lurch HTML directly into the page source (not very human-readable). Live view Source code Embedding two different (small) documents into the same webpage, and writing each in Lurch shorthand (more human-readable). See link above for instructions on writing in Lurch shorthand. Live view Source code The example HTML code above produces the embedded Lurch document shown below. Here is a Lurch document with two paragraphs, but no expressions. To see how to embed expressions, check out the examples below.","title":"Embedding Lurch in a website or blog"},{"location":"embedding/#embedding-lurch-in-a-website-or-blog","text":"","title":"Embedding Lurch in a website or blog"},{"location":"embedding/#overview","text":"When writing a web page or blog about introductory proofs, or about Lurch itself, authors will want to show examples of small documents in a live Lurch application. Validation will be functioning and showing its results, and users can explore the example interactively as well, possibly even experimenting and/or making changes. We call this embedding Lurch in a web page or blog.","title":"Overview"},{"location":"embedding/#how-to","text":"The author must do three things to embed Lurch in a blog/website: Include jQuery in the page, because the Lurch embedding script in the following bullet point depends upon it. Include this code at the top of your webpage, or in the scripts list for your blog: <script src='http://nathancarter.github.io/weblurch/app/lurch-embed-solo.min.js'></script> Create DIVs (or other blocks) with the class \"lurch-embed\" and place into them your content. You can directly paste content copied directly from the Lurch web app, or you can write in Lurch shorthand . <div class='lurch-embed'> <p>Here is a Lurch document with two paragraphs, but no expressions.</p> <p>To see how to embed expressions, check out the examples below.</p> </div>","title":"How To"},{"location":"embedding/#examples","text":"Embedding a very tiny Lurch document into a webpage by pasting raw Lurch HTML directly into the page source (not very human-readable). Live view Source code Embedding two different (small) documents into the same webpage, and writing each in Lurch shorthand (more human-readable). See link above for instructions on writing in Lurch shorthand. Live view Source code The example HTML code above produces the embedded Lurch document shown below. Here is a Lurch document with two paragraphs, but no expressions. To see how to embed expressions, check out the examples below.","title":"Examples"},{"location":"example-apps/","text":"Example Lurch Applications The webLurch project is attempting to rewrite the desktop application Lurch for the web. It is not yet complete, but the foundational technology is progressing, and can be used in other projects as well. This page lists several example applications built using the webLurch foundation. (See here for full developer info.) Beginner examples These applications truly serve no purpose except to show very small example applictaions built on the Lurch Web Platform. Simple example Developers who want to build their own apps on the webLurch platform should start here, because it's highly documented and extremely simple. Launch the app View source code \"Complex\" Example (Actually just a tiny step more complex than the simple example.) Developers who want to build their own apps on the webLurch platform should start with the Simple Example, then move to this one. It defines two group types rather than one, and shows how to add context menus and do lengthy background computations, among other things. Launch the app View source code Intermediate examples These applications actually have some useful functionaly, however small. Be sure you've started with the beginner examples above , first. Math Evaluator This one lets users wrap any typeset mathematical expression in a bubble and ask the app to evaluate it or show its internal structure. Launch the app View source code OMCD Editor This app that lets you write an OpenMath Content Dictionary in a user-friendly word processor, then export its raw XML for use elsewhere. This is a specific example of an entire category of apps for editing hierarchically structured meanings. Launch the app View source code Code Editor This app lets users insert boilerplate code from a simple programming language (with only one kind of if and one kind of loop, and a few other statements) using groups and text within them as comments. Thus the user \"codes\" in their own native language, and the app translates it into one of a few sample languages in a sidebar. JavaScript code can then be executed if the user desires. Launch the app View source code Lean UI This is the most complex demo; try one of the others to start. It lets users interact with the theorem prover Lean in a word-processing environment with nice visual feedback. Launch the app Read the tutorial View source code Main App Lurch The ongoing implementation of Lurch for the web is kept here. It is still in the beginning phases of development. For software that will check the steps of students' work, see the desktop version . No live version yet, because it is being redesigned. The most recent source code is here","title":"Example apps"},{"location":"example-apps/#example-lurch-applications","text":"The webLurch project is attempting to rewrite the desktop application Lurch for the web. It is not yet complete, but the foundational technology is progressing, and can be used in other projects as well. This page lists several example applications built using the webLurch foundation. (See here for full developer info.)","title":"Example Lurch Applications"},{"location":"example-apps/#beginner-examples","text":"These applications truly serve no purpose except to show very small example applictaions built on the Lurch Web Platform.","title":"Beginner examples"},{"location":"example-apps/#simple-example","text":"Developers who want to build their own apps on the webLurch platform should start here, because it's highly documented and extremely simple. Launch the app View source code","title":"Simple example"},{"location":"example-apps/#complex-example","text":"(Actually just a tiny step more complex than the simple example.) Developers who want to build their own apps on the webLurch platform should start with the Simple Example, then move to this one. It defines two group types rather than one, and shows how to add context menus and do lengthy background computations, among other things. Launch the app View source code","title":"\"Complex\" Example"},{"location":"example-apps/#intermediate-examples","text":"These applications actually have some useful functionaly, however small. Be sure you've started with the beginner examples above , first.","title":"Intermediate examples"},{"location":"example-apps/#math-evaluator","text":"This one lets users wrap any typeset mathematical expression in a bubble and ask the app to evaluate it or show its internal structure. Launch the app View source code","title":"Math Evaluator"},{"location":"example-apps/#omcd-editor","text":"This app that lets you write an OpenMath Content Dictionary in a user-friendly word processor, then export its raw XML for use elsewhere. This is a specific example of an entire category of apps for editing hierarchically structured meanings. Launch the app View source code","title":"OMCD Editor"},{"location":"example-apps/#code-editor","text":"This app lets users insert boilerplate code from a simple programming language (with only one kind of if and one kind of loop, and a few other statements) using groups and text within them as comments. Thus the user \"codes\" in their own native language, and the app translates it into one of a few sample languages in a sidebar. JavaScript code can then be executed if the user desires. Launch the app View source code","title":"Code Editor"},{"location":"example-apps/#lean-ui","text":"This is the most complex demo; try one of the others to start. It lets users interact with the theorem prover Lean in a word-processing environment with nice visual feedback. Launch the app Read the tutorial View source code","title":"Lean UI"},{"location":"example-apps/#main-app","text":"","title":"Main App"},{"location":"example-apps/#lurch","text":"The ongoing implementation of Lurch for the web is kept here. It is still in the beginning phases of development. For software that will check the steps of students' work, see the desktop version . No live version yet, because it is being redesigned. The most recent source code is here","title":"Lurch"},{"location":"getting-started/","text":"Getting Started This documentation is for developers who wish to learn about the Lurch Web Platform, and consider importing it into their own web projects. Try the demos online You can try out demo apps right now online . To use the platform, you can simply import the necessary files from a CDN. Stop reading here! Thta is, if you just want to use the platform in your own apps. In that case, check out the demo apps linked to above, or the developer tutorial . Only continue reading below if you want to help us develop the Lurch Web Platform itself. In that case, you need to clone and set up this repository on your machine. Here's how: Setting up a local repository Install node.js , which governs our building and testing process. (The apps run in a browser.) Then execute these commands from a *nix prompt: * Get the repository: git clone https://github.com/lurchmath/lurch.git * Enter that folder: cd lurch * Install node.js modules: npm install To compile the source, you'll want to run the build command gulp from inside the lurch folder. You may need to install gulp first; see its website. You can also run gulp test to run the unit tests. Running a local web server If you build an app on the Lurch Web Platform, and are testing it on your local machine, , you need a web server (to avoid browser security concerns with file:/// URLs). You almost certainly have Python installed, so in the folder you're building your app, do this. $ python -m SimpleHTTPServer 8000 Point your browser to localhost:8000/yourpage.html .","title":"Getting started"},{"location":"getting-started/#getting-started","text":"This documentation is for developers who wish to learn about the Lurch Web Platform, and consider importing it into their own web projects.","title":"Getting Started"},{"location":"getting-started/#try-the-demos-online","text":"You can try out demo apps right now online . To use the platform, you can simply import the necessary files from a CDN.","title":"Try the demos online"},{"location":"getting-started/#stop-reading-here","text":"Thta is, if you just want to use the platform in your own apps. In that case, check out the demo apps linked to above, or the developer tutorial . Only continue reading below if you want to help us develop the Lurch Web Platform itself. In that case, you need to clone and set up this repository on your machine. Here's how:","title":"Stop reading here!"},{"location":"getting-started/#setting-up-a-local-repository","text":"Install node.js , which governs our building and testing process. (The apps run in a browser.) Then execute these commands from a *nix prompt: * Get the repository: git clone https://github.com/lurchmath/lurch.git * Enter that folder: cd lurch * Install node.js modules: npm install To compile the source, you'll want to run the build command gulp from inside the lurch folder. You may need to install gulp first; see its website. You can also run gulp test to run the unit tests.","title":"Setting up a local repository"},{"location":"getting-started/#running-a-local-web-server","text":"If you build an app on the Lurch Web Platform, and are testing it on your local machine, , you need a web server (to avoid browser security concerns with file:/// URLs). You almost certainly have Python installed, so in the folder you're building your app, do this. $ python -m SimpleHTTPServer 8000 Point your browser to localhost:8000/yourpage.html .","title":"Running a local web server"},{"location":"plan/","text":"Project Plan This document aims to be a complete plan for what needs to be done on this project, readable by developers. It can therefore be viewed as a to-do list in chronological order, the first items being those that should be done next, and the later items those that must come after. Necessarily, the later items are more vague than the earlier ones. Note also that there are some known bugs and planned enhancements not listed in this file, because they are not part of the linear progression of the project. They can be addressed whenever it becomes convenient or useful; this document lists things in a more-or-less required order of completion. JSON editor demo app This is low priority, but another demo app you could create would be a JSON editor. It would be a lot like the OMCD editor, except produce JSON instead of XML. It would also have multiple types of atomic data, and use connections for key-value pairs in mappings. Enabling and disabling features Implement the following system satisfying the following requirements, for allowing users to enable/disable certain app features on a per-document basis. The first optional feature is pattern-based rules, so this is not necessary to implement until then. The app register a list of features (probably a short phrase naming each, plus a one-to-two-sentence description of it, plus a default value for enabled/disabled). The app can then query, at any time, the enabled/disabled status of any feature in the currently open document. At first, such a function should just return the default value. The document settings dialog will then have a section for application features, with checkboxes for enabling/disabling all registered features. Such changes will be written to document metadata. Then you can upgrade the enable/disable query function to check the document metadata first, and return the default value only if there is no information in the document metadata about the feature. Look through the OverLeaf specification for places where various features are mentioned as optional, and if any are currently implemented in the app, add code that ignores/disables them in any document for which the query function returns \"disabled\" for that feature. Ensure that there is an event that fires when document settings are changed; if there is not one, create one. At any point where a change in settings will require some kind of re-processing (e.g., the list of supported validation features was changed) be sure that a handler for the event exists and works. Parsing test Rewrite the following section to more accurately reflect Section 24 of the specification, then implement it as a module attached to the main Lurch application, a module that can easily be disabled if we need to redesign it. Add two new attribute types to the context menu for attribute expressions in the document: \"notation,\" \"type,\" and \"meaning.\" Add a new validation category for anything that has a \"notation\", \"meaning,\" or \"type\" arrow going in or out. Call it notation validation. Start notation validation by verifying that the expression being validated fits all of the following criteria. If it does not, mark it invalid. If you output type arrows, you output no other kind of arrows. Reason: A type cannot also be a notation or meaning. If you output type arrows, you take no arrows in. Reason: A type cannot be assigned any notation, type, or meaning. If you output a notation arrow, you output at most one. Reason: We currently require notation to be in exactly one category. If you output a meaning arrow, you output at most one. Reason: Notation must be unambiguous. If you output a meaning, you do not take in a type. Reason: Only patterns can have meaning, and thus they are non-atomic expressions. Types are only for atomic expressions. If you take in a meaning, you take in no notation arrows. Reason: Meanings cannot also be notational categories. If you take in a meaning, you take in no type arrows. Reason: Meanings are not notations, and thus can't have notational types. If you take in a notation, you take in no type arrows. Reason: Notational categories aren't expressions, to be assigned types. If you take in a type, you take in no other kind of arrows. Reason: This means you're the notation for an atomic type, and cannot be assigned a meaning, nor treated as a notational category. If you take in a meaning, you output no arrows. Reason: Meanings are supposed to stand alone, not be a piece of something else. If you take in a notation, you output no type arrow. Reason: Notational categories can't also be types. If you take in a type arrow, you output neither type nor meaning arrows. Reason: Only atomic notations have types, and they canont be types or meanings. Create a function that computes, for any given expression, whether it is the \"core\" of a notation definition. For a non-pattern, this is the target of the type arrow. For a pattern, this is the source of the meaning arrow. Extend that function to return false if any expression in the connected component of the attribution graph is not valid. Create a function that, for cores of notation definitions, computes a JSON representation of how to modify a parser with that new rule. Here's how: For a structure of the form [A]<--notation--[B]<--type--[C] : If C is \"built-in\" then try to read B as integer/real/letter/etc., and use a built-in regular expression to create an atomic parsing rule in category A. If C is \"regular expression\" or \"regexp\" or \"re\" then create an atomic parsing rule using B's content as a regular expression in category A. If C is \"symbol\" then create an atomic parsing rule using B as static (not a regular expression) in category A. For a structure of the form [A]<--notation--[B] : Create the parsing rule that B is a subcategory of A. For a structure of the form [A]<--notation--[B] with n other structures of the form [A1]--type-->[variables]-->[B] , and optionally a connection [B]--meaning-->[M] : Create, in category A, a grammar rule that follows the pattern in B, but with each variable replaced by its type (some Ai). As the head of the OpenMath expression that will be generated, use the OM.encodeAsIdentifier version of the first label on the definition core. If there is no label, encode the definition itself (with the types, not the variable names). Also record in the same JSON data all labels of the core, and the complete form of the meaning. That complete form will include the notational definition as an attribute, which should be removed. Create a function that applies any such JSON record of a command to a parser object, thus modifying that parser appropriately. Extend the contentsChanged handler for expressions so that, if they are part of a notation/type/meaning component in the attribution graph, find their core and call this function on it, saving the result internally, much like validation does. Whenever any such parsing JSON data is recomputed and stored, loop through all later expressions in the document, doing the following. Before the loop, create an empty parser P. Upon encountering an expression containing notation JSON data, apply to it the function that extends P with that data. Upon encountering an expression with attribute test set to true, run P on its contents and store the resulting structure as a group attribute in the expression. (If the expression doesn't parse, this may be null.) Create three functions for storing meanings in parsing test expressions: The first reads two attributes, one storing the computed meaning and one storing the official meaning (which, for now, no expression yet has, but that's coming soon). It then writes into the expression the following data. If there is no official meaning stored, decorate the close grouper with a question mark. The hover message should show the canonical form of the computed meaning, and mention that there is no official meaning against which to compare it. If there is an official meaning and it matches the computed one, decorate the close grouper with a green check (as in validation) and the tooltip can report the one (correct) meaning in canonical form. If there is an official meaning and it differs from the computed one, decorate the close grouper with a red X (as in validation) and the tooltip can report the two meanings in canonical forms. The second takes an official meaning as input, writes it to the official meaning attribute of the expression, then calls the first function to update validation. The third takes a parser and applies it to the text content of the expression, then writes it to the computed meaning attribute of the expression, then calls the first function to update validation. Update the loop that re-parses all test-type groups to use this new function to store computed meanings in test expressions, so that their visual validation results are also updated. Whenever any expression with type test set to true changes, do the same loop, but the only test that should be recomputed is the one that changed. Add a context menu item in expressions that have \"test\" set to true; it should allow you to mark a test as currently passing. This takes the currently parsed meaning of that group and stores it as the official meaning. This should trigger a change event in the group, and thus update its visual appearance. Add another context menu item for clearing out the offical meaning. Google Drive support Google Drive also provides a very nice real time collaboration API that makes any document you like into a Google-Docs-like collaborative model where changes are auto-synced across collaborators. This was an idea that Dana Ernst asked for long ago when he first heard about the webLurch project. Integrate that into webLurch, imitating the UX Ken describes from typical online collaboration apps such as Google Docs and Overleaf, as follows. Create a function that can update the UI when users log into or out of Google Drive. At first, it will just hide/show the File > Save and File > Save as... actions on the menu and toolbars. Add an HTML element to the toolbar in which we can place text about the document's dirty state, and controls for enabling cloud storage. Place a button in that element that says \"Enable cloud storage\" and make the button visible iff the user has not authenticated to Google Drive. Implement the click handler later, as described below. Create a function that can specify any message to appear to the left of that button (whether the button is visible or not). For now, whenever a new document is created, call that function with a warning message saying \"Not saved\". Provide a section in the File > Application settings... dialog that will be for Google Drive authentication. You will add the Google login functionality there later, as well as explanatory text about how cloud saving works. Implement the click handler for the \"Enable cloud storage\" button to open the application settings dialog and scroll to the Google Drive section. Add to the application settings section about Google Drive the actual login/auth button. Once a user has logged in, the button becomes a disconnect-from-my-Drive button (de-auth). See the tutorial on how to do so here , and especially the JavaScript tools they've developed for your use here . Add a handler function for when a user enables or disables cloud storage. At first, the only result will be the hiding/showing of the \"Enable Cloud Storage\" button. Extend the Google login/out handler so that logging in moves the current file into Google Drive as a new document. Attempt to preserve document title, if one was set in document properties. If Drive requires unique titles, you may need to append a number. When the file is moved into Drive, update the toolbar message to say \"Saved to Drive.\" Extend File > New so that, if the user is already logged into Drive, the new file is placed into Drive, with its default \"Untitled\" title. Also change the toolbar message to \"Saved to Drive.\" When the user makes changes to their document, queue up a syncing event for maybe 2 seconds in the future; if one was already queued, cancel it. Immediately change the toolbar message to \"Syncing...\" When the syncing event fires, save the file to Google Drive, then change the toolbar message to \"Saved to Drive\" again. Extend File > Open so that, if the user is logged into Google Drive, it replaces its old functionality with a dialog that lists all Lurch files in the Drive, as a flat list sorted by most recently used. Picking one opens the file. Create a new action, File > Open my Google Drive, that does just that, in another tab. This will be used for file management. We need to create no UI for it; Google has done so. Extend the function that can update the UI when users log into or out of Google Drive as follows: Have File > Open my Google Drive hidden by default, but shown when you log into Drive. Hide it again if you log out. We want Google Drive logins in one browser tab containing the Lurch app to impact any other browser tabs containing the Lurch app. So have the app check the application settings every second or two, and if it sees that the user has changed their Google Drive settings (stored in Local Storage, due to the user's logging into Drive in another tab of the app), then re-run the silent Google login attempt routine to complete the login in the new tab as well. (At least, this seems like it would work. Investigate.) Add to the application settings dialog, in the Google Drive authentication section, a description of how cloud storage works. Offline support To make an HTML5 app available offline, I believe the appropriate step is simply to provide an app manifest. I'm verifying that with this StackOverflow question . That question links to a tutorial on app manifests, if the answer turns out to be \"yes\" to that question. Ideas from various sources Parsing speed improvements If parsing with the current package becomes a performance bottleneck, note that there are several improvements available, some already implemented in JavaScript. See here . All images consistently base64 This GitHub comment might be useful for ensuring that even images pasted into a document get converted to base64, as all the other images in the document are. LMS integration Suggestion from Dana Ernst: Perhaps this is not necessary or feasible, but if you go with a web app, could you make it easy for teachers to \"plug into\" the common LMS's (e.g. Blackboard, Canvas, etc.)? I'm envisioning students being able to submit assignments with ease to an LMS and then teachers can grade and enter grades easily without have to go back and forth between web pages. Further wiki integration? Is it possible for the entire Lurch app to exist inside MediaWiki, so that editing a wiki page was done using Lurch as the editor? That would be excellent for many use cases. Certainly, we can use the editor in an iframe but the question is about integrating with (replacing) MediaWiki's existing editing features. You would still want to keep the normal full-page app available for those who don't want the trappings of the wiki. But it would be very intuitive, because people are familiar with wikis, and can begin as readers, then move up to being writers. Desktop app Convert webLurch into a desktop app using electron . This gives the user an app that always works offline, has an icon in their Applications folder/Start menu, etc., and feels like an official app that they can alt-tab to, etc., but it\u2019s the exact same web app, just wrapped in a thin desktop-app shell. You can then add features to that as time permits. When the user clicks \"save,\" you can have the web app first query to see if it\u2019s sitting in a desktop-app wrapper, and if so, don\u2019t save to webstorage, but pop up the usual save box. Same for File > Open. Same for accessing the system clipboard Similar apps could be created for iOS, Android, etc., but would need to use tools other than Electron. These are orthogonal tasks, and need not all be done by the same developer. Improving documentation Documentation at the top of most unit test spec files is incomplete. Add documentation so that someone who does not know how to read a test spec file could learn it from that documentation. Probably the best way to do this is to add general documentation to the simplest/main test spec, and then reference that general documentation from all other test specs. When you come to release the website for Lurch 1.0, built on the Lurch Web Platform, make Lurch citeable as research software, using this advice . Then advertise on the Lurch website how to cite it, and use that citation in your own papers about Lurch as well. It may also be appropriate to consider publishing about Lurch in this journal .","title":"Project plan"},{"location":"plan/#project-plan","text":"This document aims to be a complete plan for what needs to be done on this project, readable by developers. It can therefore be viewed as a to-do list in chronological order, the first items being those that should be done next, and the later items those that must come after. Necessarily, the later items are more vague than the earlier ones. Note also that there are some known bugs and planned enhancements not listed in this file, because they are not part of the linear progression of the project. They can be addressed whenever it becomes convenient or useful; this document lists things in a more-or-less required order of completion.","title":"Project Plan"},{"location":"plan/#json-editor-demo-app","text":"This is low priority, but another demo app you could create would be a JSON editor. It would be a lot like the OMCD editor, except produce JSON instead of XML. It would also have multiple types of atomic data, and use connections for key-value pairs in mappings.","title":"JSON editor demo app"},{"location":"plan/#enabling-and-disabling-features","text":"Implement the following system satisfying the following requirements, for allowing users to enable/disable certain app features on a per-document basis. The first optional feature is pattern-based rules, so this is not necessary to implement until then. The app register a list of features (probably a short phrase naming each, plus a one-to-two-sentence description of it, plus a default value for enabled/disabled). The app can then query, at any time, the enabled/disabled status of any feature in the currently open document. At first, such a function should just return the default value. The document settings dialog will then have a section for application features, with checkboxes for enabling/disabling all registered features. Such changes will be written to document metadata. Then you can upgrade the enable/disable query function to check the document metadata first, and return the default value only if there is no information in the document metadata about the feature. Look through the OverLeaf specification for places where various features are mentioned as optional, and if any are currently implemented in the app, add code that ignores/disables them in any document for which the query function returns \"disabled\" for that feature. Ensure that there is an event that fires when document settings are changed; if there is not one, create one. At any point where a change in settings will require some kind of re-processing (e.g., the list of supported validation features was changed) be sure that a handler for the event exists and works.","title":"Enabling and disabling features"},{"location":"plan/#parsing-test","text":"Rewrite the following section to more accurately reflect Section 24 of the specification, then implement it as a module attached to the main Lurch application, a module that can easily be disabled if we need to redesign it. Add two new attribute types to the context menu for attribute expressions in the document: \"notation,\" \"type,\" and \"meaning.\" Add a new validation category for anything that has a \"notation\", \"meaning,\" or \"type\" arrow going in or out. Call it notation validation. Start notation validation by verifying that the expression being validated fits all of the following criteria. If it does not, mark it invalid. If you output type arrows, you output no other kind of arrows. Reason: A type cannot also be a notation or meaning. If you output type arrows, you take no arrows in. Reason: A type cannot be assigned any notation, type, or meaning. If you output a notation arrow, you output at most one. Reason: We currently require notation to be in exactly one category. If you output a meaning arrow, you output at most one. Reason: Notation must be unambiguous. If you output a meaning, you do not take in a type. Reason: Only patterns can have meaning, and thus they are non-atomic expressions. Types are only for atomic expressions. If you take in a meaning, you take in no notation arrows. Reason: Meanings cannot also be notational categories. If you take in a meaning, you take in no type arrows. Reason: Meanings are not notations, and thus can't have notational types. If you take in a notation, you take in no type arrows. Reason: Notational categories aren't expressions, to be assigned types. If you take in a type, you take in no other kind of arrows. Reason: This means you're the notation for an atomic type, and cannot be assigned a meaning, nor treated as a notational category. If you take in a meaning, you output no arrows. Reason: Meanings are supposed to stand alone, not be a piece of something else. If you take in a notation, you output no type arrow. Reason: Notational categories can't also be types. If you take in a type arrow, you output neither type nor meaning arrows. Reason: Only atomic notations have types, and they canont be types or meanings. Create a function that computes, for any given expression, whether it is the \"core\" of a notation definition. For a non-pattern, this is the target of the type arrow. For a pattern, this is the source of the meaning arrow. Extend that function to return false if any expression in the connected component of the attribution graph is not valid. Create a function that, for cores of notation definitions, computes a JSON representation of how to modify a parser with that new rule. Here's how: For a structure of the form [A]<--notation--[B]<--type--[C] : If C is \"built-in\" then try to read B as integer/real/letter/etc., and use a built-in regular expression to create an atomic parsing rule in category A. If C is \"regular expression\" or \"regexp\" or \"re\" then create an atomic parsing rule using B's content as a regular expression in category A. If C is \"symbol\" then create an atomic parsing rule using B as static (not a regular expression) in category A. For a structure of the form [A]<--notation--[B] : Create the parsing rule that B is a subcategory of A. For a structure of the form [A]<--notation--[B] with n other structures of the form [A1]--type-->[variables]-->[B] , and optionally a connection [B]--meaning-->[M] : Create, in category A, a grammar rule that follows the pattern in B, but with each variable replaced by its type (some Ai). As the head of the OpenMath expression that will be generated, use the OM.encodeAsIdentifier version of the first label on the definition core. If there is no label, encode the definition itself (with the types, not the variable names). Also record in the same JSON data all labels of the core, and the complete form of the meaning. That complete form will include the notational definition as an attribute, which should be removed. Create a function that applies any such JSON record of a command to a parser object, thus modifying that parser appropriately. Extend the contentsChanged handler for expressions so that, if they are part of a notation/type/meaning component in the attribution graph, find their core and call this function on it, saving the result internally, much like validation does. Whenever any such parsing JSON data is recomputed and stored, loop through all later expressions in the document, doing the following. Before the loop, create an empty parser P. Upon encountering an expression containing notation JSON data, apply to it the function that extends P with that data. Upon encountering an expression with attribute test set to true, run P on its contents and store the resulting structure as a group attribute in the expression. (If the expression doesn't parse, this may be null.) Create three functions for storing meanings in parsing test expressions: The first reads two attributes, one storing the computed meaning and one storing the official meaning (which, for now, no expression yet has, but that's coming soon). It then writes into the expression the following data. If there is no official meaning stored, decorate the close grouper with a question mark. The hover message should show the canonical form of the computed meaning, and mention that there is no official meaning against which to compare it. If there is an official meaning and it matches the computed one, decorate the close grouper with a green check (as in validation) and the tooltip can report the one (correct) meaning in canonical form. If there is an official meaning and it differs from the computed one, decorate the close grouper with a red X (as in validation) and the tooltip can report the two meanings in canonical forms. The second takes an official meaning as input, writes it to the official meaning attribute of the expression, then calls the first function to update validation. The third takes a parser and applies it to the text content of the expression, then writes it to the computed meaning attribute of the expression, then calls the first function to update validation. Update the loop that re-parses all test-type groups to use this new function to store computed meanings in test expressions, so that their visual validation results are also updated. Whenever any expression with type test set to true changes, do the same loop, but the only test that should be recomputed is the one that changed. Add a context menu item in expressions that have \"test\" set to true; it should allow you to mark a test as currently passing. This takes the currently parsed meaning of that group and stores it as the official meaning. This should trigger a change event in the group, and thus update its visual appearance. Add another context menu item for clearing out the offical meaning.","title":"Parsing test"},{"location":"plan/#google-drive-support","text":"Google Drive also provides a very nice real time collaboration API that makes any document you like into a Google-Docs-like collaborative model where changes are auto-synced across collaborators. This was an idea that Dana Ernst asked for long ago when he first heard about the webLurch project. Integrate that into webLurch, imitating the UX Ken describes from typical online collaboration apps such as Google Docs and Overleaf, as follows. Create a function that can update the UI when users log into or out of Google Drive. At first, it will just hide/show the File > Save and File > Save as... actions on the menu and toolbars. Add an HTML element to the toolbar in which we can place text about the document's dirty state, and controls for enabling cloud storage. Place a button in that element that says \"Enable cloud storage\" and make the button visible iff the user has not authenticated to Google Drive. Implement the click handler later, as described below. Create a function that can specify any message to appear to the left of that button (whether the button is visible or not). For now, whenever a new document is created, call that function with a warning message saying \"Not saved\". Provide a section in the File > Application settings... dialog that will be for Google Drive authentication. You will add the Google login functionality there later, as well as explanatory text about how cloud saving works. Implement the click handler for the \"Enable cloud storage\" button to open the application settings dialog and scroll to the Google Drive section. Add to the application settings section about Google Drive the actual login/auth button. Once a user has logged in, the button becomes a disconnect-from-my-Drive button (de-auth). See the tutorial on how to do so here , and especially the JavaScript tools they've developed for your use here . Add a handler function for when a user enables or disables cloud storage. At first, the only result will be the hiding/showing of the \"Enable Cloud Storage\" button. Extend the Google login/out handler so that logging in moves the current file into Google Drive as a new document. Attempt to preserve document title, if one was set in document properties. If Drive requires unique titles, you may need to append a number. When the file is moved into Drive, update the toolbar message to say \"Saved to Drive.\" Extend File > New so that, if the user is already logged into Drive, the new file is placed into Drive, with its default \"Untitled\" title. Also change the toolbar message to \"Saved to Drive.\" When the user makes changes to their document, queue up a syncing event for maybe 2 seconds in the future; if one was already queued, cancel it. Immediately change the toolbar message to \"Syncing...\" When the syncing event fires, save the file to Google Drive, then change the toolbar message to \"Saved to Drive\" again. Extend File > Open so that, if the user is logged into Google Drive, it replaces its old functionality with a dialog that lists all Lurch files in the Drive, as a flat list sorted by most recently used. Picking one opens the file. Create a new action, File > Open my Google Drive, that does just that, in another tab. This will be used for file management. We need to create no UI for it; Google has done so. Extend the function that can update the UI when users log into or out of Google Drive as follows: Have File > Open my Google Drive hidden by default, but shown when you log into Drive. Hide it again if you log out. We want Google Drive logins in one browser tab containing the Lurch app to impact any other browser tabs containing the Lurch app. So have the app check the application settings every second or two, and if it sees that the user has changed their Google Drive settings (stored in Local Storage, due to the user's logging into Drive in another tab of the app), then re-run the silent Google login attempt routine to complete the login in the new tab as well. (At least, this seems like it would work. Investigate.) Add to the application settings dialog, in the Google Drive authentication section, a description of how cloud storage works.","title":"Google Drive support"},{"location":"plan/#offline-support","text":"To make an HTML5 app available offline, I believe the appropriate step is simply to provide an app manifest. I'm verifying that with this StackOverflow question . That question links to a tutorial on app manifests, if the answer turns out to be \"yes\" to that question.","title":"Offline support"},{"location":"plan/#ideas-from-various-sources","text":"","title":"Ideas from various sources"},{"location":"plan/#parsing-speed-improvements","text":"If parsing with the current package becomes a performance bottleneck, note that there are several improvements available, some already implemented in JavaScript. See here .","title":"Parsing speed improvements"},{"location":"plan/#all-images-consistently-base64","text":"This GitHub comment might be useful for ensuring that even images pasted into a document get converted to base64, as all the other images in the document are.","title":"All images consistently base64"},{"location":"plan/#lms-integration","text":"Suggestion from Dana Ernst: Perhaps this is not necessary or feasible, but if you go with a web app, could you make it easy for teachers to \"plug into\" the common LMS's (e.g. Blackboard, Canvas, etc.)? I'm envisioning students being able to submit assignments with ease to an LMS and then teachers can grade and enter grades easily without have to go back and forth between web pages.","title":"LMS integration"},{"location":"plan/#further-wiki-integration","text":"Is it possible for the entire Lurch app to exist inside MediaWiki, so that editing a wiki page was done using Lurch as the editor? That would be excellent for many use cases. Certainly, we can use the editor in an iframe but the question is about integrating with (replacing) MediaWiki's existing editing features. You would still want to keep the normal full-page app available for those who don't want the trappings of the wiki. But it would be very intuitive, because people are familiar with wikis, and can begin as readers, then move up to being writers.","title":"Further wiki integration?"},{"location":"plan/#desktop-app","text":"Convert webLurch into a desktop app using electron . This gives the user an app that always works offline, has an icon in their Applications folder/Start menu, etc., and feels like an official app that they can alt-tab to, etc., but it\u2019s the exact same web app, just wrapped in a thin desktop-app shell. You can then add features to that as time permits. When the user clicks \"save,\" you can have the web app first query to see if it\u2019s sitting in a desktop-app wrapper, and if so, don\u2019t save to webstorage, but pop up the usual save box. Same for File > Open. Same for accessing the system clipboard Similar apps could be created for iOS, Android, etc., but would need to use tools other than Electron. These are orthogonal tasks, and need not all be done by the same developer.","title":"Desktop app"},{"location":"plan/#improving-documentation","text":"Documentation at the top of most unit test spec files is incomplete. Add documentation so that someone who does not know how to read a test spec file could learn it from that documentation. Probably the best way to do this is to add general documentation to the simplest/main test spec, and then reference that general documentation from all other test specs. When you come to release the website for Lurch 1.0, built on the Lurch Web Platform, make Lurch citeable as research software, using this advice . Then advertise on the Lurch website how to cite it, and use that citation in your own papers about Lurch as well. It may also be appropriate to consider publishing about Lurch in this journal .","title":"Improving documentation"},{"location":"repo-migration-plans/","text":"Plans for Migrating this Repository We plan to migrate this repository to a GitHub organization shared by both project collaborators, Nathan Carter and Ken Monks . Reasons for the move: The project plan file already lists several ways in which this repository needs to be tidied up. Those plans will be accomplished as part of the migration. Until now, Nathan has been the primary author, but Ken will be getting more involved in the development from this point forward. Thus a shared space is sensible. We also hope to have other developers and student assistants join us in the future, thereby making the organization account even more sensible and useful. The move will simplify our URL to something easier to remember, lurchmath.github.io . (At the time of this writing, that URL has no content at it. One of the tasks listed below is to create such content.) Preparing the new space The organization account has been created, Nathan is an owner, and Ken has been invited as a member. Tasks to do to complete the space include these: [x] Create a project with name lurchmath.github.io owned by the organization, following the directions on this page . [x] Ensure both collaborators have ownership of/access to this project. [x] For consistency with the existing repo, let's use MkDocs to create that site. Follow the directions here to get started. You probably want to add a redirection page from the root folder to the site/ folder, or configure GitHub to go there without a redirection page needed (better option if possible). For now, make a placeholder website we can extend later. [x] Create a README.md in that project that simply points the reader to the website. Moving the first subproject over One of the repository tidying tasks is to factor out independent subprojects into their own repositories, and use GitHub pages like a CDN for serving their compiled JavaScript versions. Another goal is to start using a build tool, and I've chosen Gulp as what seems best for our needs. We will try both of those things out on a single subproject, to test and cement a good process before proceeding to factor out other subprojects. We will use the OpenMath module as the first subproject to factor out into its own repository. As you do the following steps, record somewhere the proper way to do each one, so that you can repeat this process for other subprojects more easily hereafter. [x] Create a new project in the Lurch Math organization for the OpenMath JavaScript library and clone it to your local machine. [x] Copy the source and test files to the new repository, in its root folder. Rename them to openmath.litcoffee and spec.litcoffee , respectively. Commit. [x] Create a package.json file that imports the Jasmine test tool. Ensure that you can run Jasmine on the spec file and that the tests pass; modify any paths necessary to make this happen. Commit. [x] Install Gulp and create a Gulpfile that does nothing. Commit. [x] Extend the Gulpfile to compile a JavaScript version of the OpenMath module. Add the .js file to the repo and commit. [x] Extend the Gulpfile to also compile a minified version, with source maps. Add these files to the repository and commit again. [x] Extend the Gulpfile with a tests task that runs the Jasmine command on your behalf. Commit. [x] Register the project with TravisCI so that the tests are run on every push to the repository. [x] Create a README.md in the repository root that explains the project and includes the TravisCI test status image. It should refer the user to the GitHub links to the raw compiled and minified scripts, so that GitHub can be used as a makeshift CDN. [x] Add documentation for this subproject using MkDocs , as you did for the new Lurch Math organization. Follow the directions here to get started. Commit. [x] Extend the Gulpfile with a docs task that runs the mkdocs command on your behalf. Commit. [x] Remove the OpenMath code from the existing webLurch repository, instead importing it using the makeshift CDN mentioned above. Change all references to it in the documentation to mention the newly-factored-out repository in the new organization. Verify that all uses of that module still function in the main webLurch repository, and commit changes there. Moving more subprojects over Once you've accomplished the process in the previous section, and documented it well so that you can do it more smoothly the second time (and the third, and so on), do that process to factor out each of the following subprojects from the main, existing webLurch repository. [x] The Parsing module [x] The Matching module Supporting Cloud Storage Now that the cloud storage module has been built and tested, it should replace both the LocalStorage and baby Dropbox support in webLurch at present. Here's a to-do list for accomplishing that. [x] Update the cloud storage module to show how to import its files with jsDelivr in the README. [x] Have all the apps import the cloud storage module from that CDN, before importing app.js , and ensure that nothing gets broken in the process. The module won't be used yet, just imported for later. [x] Make a copy of the Load/Save Plugin and call it the Cloud Storage Plugin instead, renaming it in both filename and script code. [x] Ensure that the Cloud Storage Plugin is part of the build process and is included in the app and installed in the editor object. [x] Figure out a way to get the cloud storage tools to function exclusively from cloud. This may involve using GitHub web serving, since jsdelivr won't serve HTML pages as HTML pages. If this can't be done, at least move the tools into a subfolder of the app folder, and enhance their API so that they can support living in a subfolder. Then extend the build process to always fetch the latest versions. (Or add that as a task to be done once grunt is adopted.) [x] Replace the LoadSave plugin and the Dropbox plugin with a single Storage plugin, as follows. [x] Rename the DropboxPlugin to the StoragePlugin [x] Translate the following code from LoadSave to Storage: [x] All code in the constructor section, except Manage Files item [x] Add to the constructor the creation of both back ends [x] All code in the setters section [x] Add a member that reports all available back ends [x] Add a member that lets users get/set which back end is active [x] All code in the new documents section [x] All code in the saving documents section except save [x] Replace tryToSave with the handler Dropbox would install [x] Create the \"loading documents\" section in the Storage plugin [x] Convert the old @load member to one that takes the [content,metadata] array as input and loads it into the editor [x] Create a new function for loading a named file from LocalStorage, returning [content,metadata] ; no editor updating [x] Ensure the Storage plugin exposes a filename member; this should be easy to do whenever you update lastFileObject [x] Update DependenciesPlugin.getFileMetadata to call the new Storage plugin function that loads files from LocalStorage [x] Update setup.litcoffee to say storage instead of cloudstorage [x] Ensure that the install procedure for the StoragePlugin calls it storage and not dropbox [x] Remove from setup.litcoffee the loadsave plugin [x] Replace every instance of LoadSave with Storage throughout [x] Remove the LoadSave plugin entirely from the application. [x] Update the wiki plugin because you've implemented embedMetadata and extractMetadata in the Storage plugin now, so they aren't globally defined, and don't need to be redefined in the wiki plugin. Also, everyone who calls them should do so through the Storage plugin. [x] In main-app-settings.litcoffee , change the setFilesystem function so that any chosen filesystem calls the new API function in the Storage plugin, telling it to change to that filesystem. Ensure that the right options are provided as radio buttons, up around line 47. Test to be sure that all filesystems now work. [x] Ensure that no reference to the jsfs submodule remains in the application. [x] Update any other demo apps to remove all references to the jsfs submodule. [x] Remove the jsfs submodule from the repository. Ensure that the applications still function. [x] Remove the old file dialog source . Ensure that the applications still function. [x] Get rid of the LZString JS library from our repository. Ensure that the applications still function. [x] Make the functionality improvements listed in the cloud storage repo. Obviating some files in the repository [x] Because our only targeted browser is Chrome, which now supports navigator.hardwardConcurrency natively, you can drop the core-estimator files in the repository, and update any code to use the native version instead (if any updates are even needed). Be sure to stop importing the removed polyfill. [x] Get rid of the jquery-splitter/ folder and submodule. Instead, use the following CDN URLs: https://cdn.jsdelivr.net/gh/jcubic/jquery.splitter@0.24/js/jquery.splitter.min.js and https://cdn.jsdelivr.net/gh/jcubic/jquery.splitter@0.24/css/jquery.splitter.min.css Starting a new main repository [x] Create a new project in the Lurch Math organization for receiving the main repository, as we slowly transfer pieces over, cleaning cruft as we go. Call it Lurch . Ensure both collaborators have permissions. [x] Transfer the README.md from the old repository (with any needed images and updated links) to the new one. Commit. [x] Start documentation for this project using MkDocs , as you did in previous projects. Follow the directions here to get started. Use a docs/ subfolder that compiles to a site/ subfolder. For now, it should be 99% blank, just a placeholder for where future documentation will go. Commit. [x] Ensure that GitHub is set up to use the root of the project as the web site, and create an index.html that is a one-line redirecting META tag into the site/ folder, as we did earlier. [x] Create a Gulpfile with a docs task that runs the mkdocs command on your behalf. Commit. Moving large chunks of code that will get used later [x] Create a source/modules subfolder in the new repository and move into it all remaining code in the src/ folder of the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] Create a source/plugins subfolder in the new repository and move into it all files matching app/*plugin.litcoffee from the old repository. Also move any files that those plugins require, such as .css files. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] Move the following important source files from the old repo into source/ in the new repo. Commit, again mentioning this is part of an ongoing migration. [x] keyboard-shortcuts-workaround.litcoffee [x] mathquill-parser-solo.litcoffee [x] setup.litcoffee [x] testrecorder-solo.litcoffee [x] testrecorder.html [x] testrecorder.litcoffee [x] lurch-embed-solo.litcoffee [x] Create a source/experimental subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] cp-test-solo.litcoffee [x] cp-test.html [x] lpf-test-solo.litcoffee [x] lpf-test.html [x] Create a source/main-app subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] main-app-attr-dialog-solo.litcoffee (dropping the main-app- ) [x] main-app-basics-solo. (dropping the main-app- ) [x] main-app-group-class-solo. (dropping the main-app- ) [x] main-app-group-labels-solo. (dropping the main-app- ) [x] main-app-group-validation-solo. (dropping the main-app- ) [x] main-app-groups-solo. (dropping the main-app- ) [x] main-app-import-export-solo. (dropping the main-app- ) [x] main-app-proto-groups-solo. (dropping the main-app- ) [x] main-app-settings-solo. (dropping the main-app- ) [x] main-app-sharing-solo. (dropping the main-app- ) [x] app.html [x] Create a source/assets subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] eqed/ folder [x] input-method.js (Which is online here, if you want to import it from GitHub raw, like a fake CDN: https://leanprover.github.io/tutorial/js/input-method.js) [x] icons/ folder [x] images/ folder [x] Create a unit-tests subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] app-test-utils.litcoffee [x] domutils-spec.litcoffee [x] groupsplugin-change-spec.litcoffee [x] groupsplugin-spec.litcoffee [x] loadsaveplugin-spec.litcoffee [x] overlayplugin-spec.litcoffee [x] phantom-utils.litcoffee [x] tinymce-basics-spec.litcoffee [x] utils-spec.litcoffee [x] embedding/ folder Beginning to use the migrated code [x] Rename files that end with -solo to not have that suffix. [x] Create a release/ folder within the new repository. [x] Implement a gulp task called lwp-build that concatenates all the following into a single file, in this order, then compiles it with minification and source maps into release/lurch-web-platform.* : source/modules/utils.litcoffee source/modules/domutils.litcoffee source/modules/canvasutils.litcoffee source/plugins/*.litcoffee source/auxiliary/keyboard-shortcuts-workaround.litcoffee source/auxiliary/testrecorder.litcoffee source/auxiliary/setup.litcoffee [x] Implement a gulp task called build-auxiliary-js-files that compiles each of the following files, with minification and source maps, into the release/ folder. source/auxiliary/lurch-embed.litcoffee source/auxiliary/mathquill-parser.litcoffee source/auxiliary/testrecorder.litcoffee source/auxiliary/background.litcoffee source/auxiliary/worker.litcoffee [x] Implement a gulp task called build-experiments that compiles (with minification and source maps) source/experiments/*.litcoffee into the same (experiments) folder. [x] Implement a default gulp task that runs all the previous ones. [x] Test that this has succeeded by temporarily moving into the new repo the compiled versions of simple-example*.* from the old repo's app/ folder, and verifying that the example still runs. Do not keep these files in the new repo; move them out and then commit the changes. (But keep the files so that you can use them in the next stage, below.) Creating demo apps as separate projects Consider each of the following example applications. [x] simple-example*.* [x] complex-example*.* [x] math-example*.* [x] openmath-example*.* [x] lean-example*.* [x] sidebar-example*.* For each of them, do all of the following steps. Create a new project to house the example. mkdir lwp-example- cd lwp-example- git init On https://github.com/lurchmath, click New. Give the repo the name lwp-example-<name> . Description: example built on the Lurch Web Platform. Don't initialize with a README; just Create repository. git remote add origin https://github.com/lurchmath/lwp-example- .git Move files in. cp ../../weblurch/app/ -example . . mv -example.html index.html Rename the other files to lwp-example-<name>.* . git add --all git commit -m 'Importing files from old webLurch repo (with renaming)' git push -u origin master Update index.html, mimicking lwp-example-simple/index.html, which is a very different style than it was. Test with a local web server, and get it working. Open that new repo in GitHub desktop. Commit. Create a build process. npm install gulp gulp-coffee gulp-uglify gulp-sourcemaps pump --save-dev Create a .gitignore that mentions node_modules. It should compile and minify the source code all in the root dir. Remove any files not generated by that build process. Commit and push. Add a README. It should explain the repository briefly. It should direct readers into the literate source for details. It should also link to the build process source. Commit and push. Web space: Visit https://github.com/lurchmath/lwp-example- . Click Settings, scroll down to GitHub Pages. Choose Master branch, click Save. Verify that the application works when you visit https://lurchmath.github.io/lwp-example- Add to the README a link to the functioning app at that URL. Commit and push. Update source code. Update links in addHelpMenuSourceCodeLink and helpAboutText . Update links in any of the Markdown documentation. Read the literate comments and fix anything else out-of-date. Be sure there is a link to the main project repo: https://github.com/lurchmath/lurch Handling experimental content [x] Create a Gulp build process called experimental that compiles and minifies all the code in the source/experimental/ folder in the new repository, leaving it in that folder so it doesn't accidentally get committed to the repository. [x] Ensure that the HTML files in that directory correctly import the Lurch Web Platform from the parent directory ( site/ ). [x] Ensure that the experimental HTML apps in that folder still function (or at least function as well as they do in the old repo). Commit. Miscellaneous [x] Update lurch-embed.litcoffee to function in the new space. [x] Since you've changed the Api-User-Agent of the MediaWiki Plugin from \"webLurch Application\" to \"Lurch Application,\" check to see if your MediaWiki modifications on the other end are sensitive to that, and if so, update them. [x] Add a README to the main-app folder, explaining that it is a half-built app that works well so far, but we're not yet making it live in this new repo because we're redesigning it and a lot may change. [x] Add to the new repository a record of all changes performed on MediaWiki to get it working with Lurch. Migrating unit tests [x] Make a Gulp task called tests that initially does nothing. Commit, but mention that obviously this is not yet complete. [x] Extend that Gulp task so that it runs any unit tests that do not yet need PhantomJS . Ensure that they run (not necessarily passing yet) and then commit. Migrating documentation [ ] Copy all the content from the old repo's doc-src/ folder into the new repo's docs/ folder. Do not commit. [ ] Transfer the contents of the mkdocs.yml file into this new repository. Do not commit. [ ] Move off to the side all files that teach how to use the main Lurch app, because that has not yet been transferred/updated/designed in this new context. Ensure they are removed from mkdocs.yml . Do not commit. [ ] Create a gulp build process that runs mkdocs. Ensure that it works, even though the docs aren't yet updated. Commit. [ ] Proofread each page in the new site, updating any links or explanations to be accurate and up-to-date after all the recent migration changes. This should include explaining what's going on with the main app, in its limbo state. Test often as you write, using the Gulp task that builds the documentation. Commit. [ ] Update setup.litcoffee , in which I formerly commented out the section linking to the developer tutorial from the Help menu. Now you can add that link back in, to the new developer tutorial. [ ] Update the README in the lwp-example-lean repository to reference the full Lean tutorial documentation. While you're at it, check to see if that app actually uses the equation editor at all. If not, remove the eqed/ subfolder from that repository, as well as the scripts imported from it, just to simplify things. Preparing various repos to be used in WebWorkers [ ] Extend the first-order matching package with a function that checks to see if the script is being run in a WebWorker. Just check for the presence of the global WorkerGlobalScope object. If it is, then install a message listener that exposes the entire matching API to the parent window. Recall the functions for doing so, described here . [ ] Extend the tests in that module to ensure that the in-worker version works just fine when accessed by message-passing. You can get a WebWorker shim for node.js here . To do async testing in Jasmine, see the documentation on that feature here . [ ] Commit and push those changes. [ ] Extend the documentation in the mkdocs site in that repo so that it mentions the WebWorker support, showing how to use it, and linking to the relevant portions of the source code and testing spec. Commit, push. [ ] Update the minor version number and re-publish to npm. [ ] Extend the Earley Parsing package with a function that checks to see if the script is being run in a WebWorker. Just check for the presence of the global WorkerGlobalScope object. If it is, then install a message listener that exposes the entire parsing API to the parent window. Recall the functions for doing so, described here . [ ] Extend the tests in that module to ensure that the in-worker version works just fine when accessed by message-passing. You can get a WebWorker shim for node.js here . To do async testing in Jasmine, see the documentation on that feature [ ] Commit and push those changes. [ ] Extend the documentation in the mkdocs site in that repo so that it mentions the WebWorker support, showing how to use it, and linking to the relevant portions of the source code and testing spec. Commit, push. [ ] Update the minor version number and re-publish to npm. Warning It may be best to stop here for now, until our design efforts progress far enough that we know with some certainty whether the following tasks still make sense, or at least know better how to do them correctly. Handling the main app [ ] Create a Gulp build process called main-app that compiles and minifies all the code in the source/main-app/ folder in the new repository, and copies all the result into a site/app/ directory, having first deleted everything in that folder. [ ] Ensure that the HTML file in that directory correctly imports the Lurch Web Platform from the parent directory ( site/ ). [ ] Ensure that the HTML app in that folder still functions, just as it does in the old repo. Commit. [ ] Once there is a main app, update the old unit tests to load the main page of that app and test themselves against it. Add those unit tests to the gulp test process. Adding in-browser testing [ ] Add PhantomJS to the package.json file of the new repository, following the lead of how this was first done in the old repository. [ ] Extend the Gulp tests task so that it successfully runs the simplest of the unit tests that require PhantomJS (probably domutils ). Commit. [ ] Extend the Gulp tests task iteratively with new unit tests that require PhantomJS, fixing errors as you proceed, committing after each.","title":"Plans for Migrating this Repository"},{"location":"repo-migration-plans/#plans-for-migrating-this-repository","text":"We plan to migrate this repository to a GitHub organization shared by both project collaborators, Nathan Carter and Ken Monks . Reasons for the move: The project plan file already lists several ways in which this repository needs to be tidied up. Those plans will be accomplished as part of the migration. Until now, Nathan has been the primary author, but Ken will be getting more involved in the development from this point forward. Thus a shared space is sensible. We also hope to have other developers and student assistants join us in the future, thereby making the organization account even more sensible and useful. The move will simplify our URL to something easier to remember, lurchmath.github.io . (At the time of this writing, that URL has no content at it. One of the tasks listed below is to create such content.)","title":"Plans for Migrating this Repository"},{"location":"repo-migration-plans/#preparing-the-new-space","text":"The organization account has been created, Nathan is an owner, and Ken has been invited as a member. Tasks to do to complete the space include these: [x] Create a project with name lurchmath.github.io owned by the organization, following the directions on this page . [x] Ensure both collaborators have ownership of/access to this project. [x] For consistency with the existing repo, let's use MkDocs to create that site. Follow the directions here to get started. You probably want to add a redirection page from the root folder to the site/ folder, or configure GitHub to go there without a redirection page needed (better option if possible). For now, make a placeholder website we can extend later. [x] Create a README.md in that project that simply points the reader to the website.","title":"Preparing the new space"},{"location":"repo-migration-plans/#moving-the-first-subproject-over","text":"One of the repository tidying tasks is to factor out independent subprojects into their own repositories, and use GitHub pages like a CDN for serving their compiled JavaScript versions. Another goal is to start using a build tool, and I've chosen Gulp as what seems best for our needs. We will try both of those things out on a single subproject, to test and cement a good process before proceeding to factor out other subprojects. We will use the OpenMath module as the first subproject to factor out into its own repository. As you do the following steps, record somewhere the proper way to do each one, so that you can repeat this process for other subprojects more easily hereafter. [x] Create a new project in the Lurch Math organization for the OpenMath JavaScript library and clone it to your local machine. [x] Copy the source and test files to the new repository, in its root folder. Rename them to openmath.litcoffee and spec.litcoffee , respectively. Commit. [x] Create a package.json file that imports the Jasmine test tool. Ensure that you can run Jasmine on the spec file and that the tests pass; modify any paths necessary to make this happen. Commit. [x] Install Gulp and create a Gulpfile that does nothing. Commit. [x] Extend the Gulpfile to compile a JavaScript version of the OpenMath module. Add the .js file to the repo and commit. [x] Extend the Gulpfile to also compile a minified version, with source maps. Add these files to the repository and commit again. [x] Extend the Gulpfile with a tests task that runs the Jasmine command on your behalf. Commit. [x] Register the project with TravisCI so that the tests are run on every push to the repository. [x] Create a README.md in the repository root that explains the project and includes the TravisCI test status image. It should refer the user to the GitHub links to the raw compiled and minified scripts, so that GitHub can be used as a makeshift CDN. [x] Add documentation for this subproject using MkDocs , as you did for the new Lurch Math organization. Follow the directions here to get started. Commit. [x] Extend the Gulpfile with a docs task that runs the mkdocs command on your behalf. Commit. [x] Remove the OpenMath code from the existing webLurch repository, instead importing it using the makeshift CDN mentioned above. Change all references to it in the documentation to mention the newly-factored-out repository in the new organization. Verify that all uses of that module still function in the main webLurch repository, and commit changes there.","title":"Moving the first subproject over"},{"location":"repo-migration-plans/#moving-more-subprojects-over","text":"Once you've accomplished the process in the previous section, and documented it well so that you can do it more smoothly the second time (and the third, and so on), do that process to factor out each of the following subprojects from the main, existing webLurch repository. [x] The Parsing module [x] The Matching module","title":"Moving more subprojects over"},{"location":"repo-migration-plans/#supporting-cloud-storage","text":"Now that the cloud storage module has been built and tested, it should replace both the LocalStorage and baby Dropbox support in webLurch at present. Here's a to-do list for accomplishing that. [x] Update the cloud storage module to show how to import its files with jsDelivr in the README. [x] Have all the apps import the cloud storage module from that CDN, before importing app.js , and ensure that nothing gets broken in the process. The module won't be used yet, just imported for later. [x] Make a copy of the Load/Save Plugin and call it the Cloud Storage Plugin instead, renaming it in both filename and script code. [x] Ensure that the Cloud Storage Plugin is part of the build process and is included in the app and installed in the editor object. [x] Figure out a way to get the cloud storage tools to function exclusively from cloud. This may involve using GitHub web serving, since jsdelivr won't serve HTML pages as HTML pages. If this can't be done, at least move the tools into a subfolder of the app folder, and enhance their API so that they can support living in a subfolder. Then extend the build process to always fetch the latest versions. (Or add that as a task to be done once grunt is adopted.) [x] Replace the LoadSave plugin and the Dropbox plugin with a single Storage plugin, as follows. [x] Rename the DropboxPlugin to the StoragePlugin [x] Translate the following code from LoadSave to Storage: [x] All code in the constructor section, except Manage Files item [x] Add to the constructor the creation of both back ends [x] All code in the setters section [x] Add a member that reports all available back ends [x] Add a member that lets users get/set which back end is active [x] All code in the new documents section [x] All code in the saving documents section except save [x] Replace tryToSave with the handler Dropbox would install [x] Create the \"loading documents\" section in the Storage plugin [x] Convert the old @load member to one that takes the [content,metadata] array as input and loads it into the editor [x] Create a new function for loading a named file from LocalStorage, returning [content,metadata] ; no editor updating [x] Ensure the Storage plugin exposes a filename member; this should be easy to do whenever you update lastFileObject [x] Update DependenciesPlugin.getFileMetadata to call the new Storage plugin function that loads files from LocalStorage [x] Update setup.litcoffee to say storage instead of cloudstorage [x] Ensure that the install procedure for the StoragePlugin calls it storage and not dropbox [x] Remove from setup.litcoffee the loadsave plugin [x] Replace every instance of LoadSave with Storage throughout [x] Remove the LoadSave plugin entirely from the application. [x] Update the wiki plugin because you've implemented embedMetadata and extractMetadata in the Storage plugin now, so they aren't globally defined, and don't need to be redefined in the wiki plugin. Also, everyone who calls them should do so through the Storage plugin. [x] In main-app-settings.litcoffee , change the setFilesystem function so that any chosen filesystem calls the new API function in the Storage plugin, telling it to change to that filesystem. Ensure that the right options are provided as radio buttons, up around line 47. Test to be sure that all filesystems now work. [x] Ensure that no reference to the jsfs submodule remains in the application. [x] Update any other demo apps to remove all references to the jsfs submodule. [x] Remove the jsfs submodule from the repository. Ensure that the applications still function. [x] Remove the old file dialog source . Ensure that the applications still function. [x] Get rid of the LZString JS library from our repository. Ensure that the applications still function. [x] Make the functionality improvements listed in the cloud storage repo.","title":"Supporting Cloud Storage"},{"location":"repo-migration-plans/#obviating-some-files-in-the-repository","text":"[x] Because our only targeted browser is Chrome, which now supports navigator.hardwardConcurrency natively, you can drop the core-estimator files in the repository, and update any code to use the native version instead (if any updates are even needed). Be sure to stop importing the removed polyfill. [x] Get rid of the jquery-splitter/ folder and submodule. Instead, use the following CDN URLs: https://cdn.jsdelivr.net/gh/jcubic/jquery.splitter@0.24/js/jquery.splitter.min.js and https://cdn.jsdelivr.net/gh/jcubic/jquery.splitter@0.24/css/jquery.splitter.min.css","title":"Obviating some files in the repository"},{"location":"repo-migration-plans/#starting-a-new-main-repository","text":"[x] Create a new project in the Lurch Math organization for receiving the main repository, as we slowly transfer pieces over, cleaning cruft as we go. Call it Lurch . Ensure both collaborators have permissions. [x] Transfer the README.md from the old repository (with any needed images and updated links) to the new one. Commit. [x] Start documentation for this project using MkDocs , as you did in previous projects. Follow the directions here to get started. Use a docs/ subfolder that compiles to a site/ subfolder. For now, it should be 99% blank, just a placeholder for where future documentation will go. Commit. [x] Ensure that GitHub is set up to use the root of the project as the web site, and create an index.html that is a one-line redirecting META tag into the site/ folder, as we did earlier. [x] Create a Gulpfile with a docs task that runs the mkdocs command on your behalf. Commit.","title":"Starting a new main repository"},{"location":"repo-migration-plans/#moving-large-chunks-of-code-that-will-get-used-later","text":"[x] Create a source/modules subfolder in the new repository and move into it all remaining code in the src/ folder of the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] Create a source/plugins subfolder in the new repository and move into it all files matching app/*plugin.litcoffee from the old repository. Also move any files that those plugins require, such as .css files. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] Move the following important source files from the old repo into source/ in the new repo. Commit, again mentioning this is part of an ongoing migration. [x] keyboard-shortcuts-workaround.litcoffee [x] mathquill-parser-solo.litcoffee [x] setup.litcoffee [x] testrecorder-solo.litcoffee [x] testrecorder.html [x] testrecorder.litcoffee [x] lurch-embed-solo.litcoffee [x] Create a source/experimental subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] cp-test-solo.litcoffee [x] cp-test.html [x] lpf-test-solo.litcoffee [x] lpf-test.html [x] Create a source/main-app subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] main-app-attr-dialog-solo.litcoffee (dropping the main-app- ) [x] main-app-basics-solo. (dropping the main-app- ) [x] main-app-group-class-solo. (dropping the main-app- ) [x] main-app-group-labels-solo. (dropping the main-app- ) [x] main-app-group-validation-solo. (dropping the main-app- ) [x] main-app-groups-solo. (dropping the main-app- ) [x] main-app-import-export-solo. (dropping the main-app- ) [x] main-app-proto-groups-solo. (dropping the main-app- ) [x] main-app-settings-solo. (dropping the main-app- ) [x] main-app-sharing-solo. (dropping the main-app- ) [x] app.html [x] Create a source/assets subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] eqed/ folder [x] input-method.js (Which is online here, if you want to import it from GitHub raw, like a fake CDN: https://leanprover.github.io/tutorial/js/input-method.js) [x] icons/ folder [x] images/ folder [x] Create a unit-tests subfolder in the new repository and move into it the following files from the old repository. Commit, but mention that these files are not yet used for anything, and are just part of an ongoing migration process. [x] app-test-utils.litcoffee [x] domutils-spec.litcoffee [x] groupsplugin-change-spec.litcoffee [x] groupsplugin-spec.litcoffee [x] loadsaveplugin-spec.litcoffee [x] overlayplugin-spec.litcoffee [x] phantom-utils.litcoffee [x] tinymce-basics-spec.litcoffee [x] utils-spec.litcoffee [x] embedding/ folder","title":"Moving large chunks of code that will get used later"},{"location":"repo-migration-plans/#beginning-to-use-the-migrated-code","text":"[x] Rename files that end with -solo to not have that suffix. [x] Create a release/ folder within the new repository. [x] Implement a gulp task called lwp-build that concatenates all the following into a single file, in this order, then compiles it with minification and source maps into release/lurch-web-platform.* : source/modules/utils.litcoffee source/modules/domutils.litcoffee source/modules/canvasutils.litcoffee source/plugins/*.litcoffee source/auxiliary/keyboard-shortcuts-workaround.litcoffee source/auxiliary/testrecorder.litcoffee source/auxiliary/setup.litcoffee [x] Implement a gulp task called build-auxiliary-js-files that compiles each of the following files, with minification and source maps, into the release/ folder. source/auxiliary/lurch-embed.litcoffee source/auxiliary/mathquill-parser.litcoffee source/auxiliary/testrecorder.litcoffee source/auxiliary/background.litcoffee source/auxiliary/worker.litcoffee [x] Implement a gulp task called build-experiments that compiles (with minification and source maps) source/experiments/*.litcoffee into the same (experiments) folder. [x] Implement a default gulp task that runs all the previous ones. [x] Test that this has succeeded by temporarily moving into the new repo the compiled versions of simple-example*.* from the old repo's app/ folder, and verifying that the example still runs. Do not keep these files in the new repo; move them out and then commit the changes. (But keep the files so that you can use them in the next stage, below.)","title":"Beginning to use the migrated code"},{"location":"repo-migration-plans/#creating-demo-apps-as-separate-projects","text":"Consider each of the following example applications. [x] simple-example*.* [x] complex-example*.* [x] math-example*.* [x] openmath-example*.* [x] lean-example*.* [x] sidebar-example*.* For each of them, do all of the following steps. Create a new project to house the example. mkdir lwp-example- cd lwp-example- git init On https://github.com/lurchmath, click New. Give the repo the name lwp-example-<name> . Description: example built on the Lurch Web Platform. Don't initialize with a README; just Create repository. git remote add origin https://github.com/lurchmath/lwp-example- .git Move files in. cp ../../weblurch/app/ -example . . mv -example.html index.html Rename the other files to lwp-example-<name>.* . git add --all git commit -m 'Importing files from old webLurch repo (with renaming)' git push -u origin master Update index.html, mimicking lwp-example-simple/index.html, which is a very different style than it was. Test with a local web server, and get it working. Open that new repo in GitHub desktop. Commit. Create a build process. npm install gulp gulp-coffee gulp-uglify gulp-sourcemaps pump --save-dev Create a .gitignore that mentions node_modules. It should compile and minify the source code all in the root dir. Remove any files not generated by that build process. Commit and push. Add a README. It should explain the repository briefly. It should direct readers into the literate source for details. It should also link to the build process source. Commit and push. Web space: Visit https://github.com/lurchmath/lwp-example- . Click Settings, scroll down to GitHub Pages. Choose Master branch, click Save. Verify that the application works when you visit https://lurchmath.github.io/lwp-example- Add to the README a link to the functioning app at that URL. Commit and push. Update source code. Update links in addHelpMenuSourceCodeLink and helpAboutText . Update links in any of the Markdown documentation. Read the literate comments and fix anything else out-of-date. Be sure there is a link to the main project repo: https://github.com/lurchmath/lurch","title":"Creating demo apps as separate projects"},{"location":"repo-migration-plans/#handling-experimental-content","text":"[x] Create a Gulp build process called experimental that compiles and minifies all the code in the source/experimental/ folder in the new repository, leaving it in that folder so it doesn't accidentally get committed to the repository. [x] Ensure that the HTML files in that directory correctly import the Lurch Web Platform from the parent directory ( site/ ). [x] Ensure that the experimental HTML apps in that folder still function (or at least function as well as they do in the old repo). Commit.","title":"Handling experimental content"},{"location":"repo-migration-plans/#miscellaneous","text":"[x] Update lurch-embed.litcoffee to function in the new space. [x] Since you've changed the Api-User-Agent of the MediaWiki Plugin from \"webLurch Application\" to \"Lurch Application,\" check to see if your MediaWiki modifications on the other end are sensitive to that, and if so, update them. [x] Add a README to the main-app folder, explaining that it is a half-built app that works well so far, but we're not yet making it live in this new repo because we're redesigning it and a lot may change. [x] Add to the new repository a record of all changes performed on MediaWiki to get it working with Lurch.","title":"Miscellaneous"},{"location":"repo-migration-plans/#migrating-unit-tests","text":"[x] Make a Gulp task called tests that initially does nothing. Commit, but mention that obviously this is not yet complete. [x] Extend that Gulp task so that it runs any unit tests that do not yet need PhantomJS . Ensure that they run (not necessarily passing yet) and then commit.","title":"Migrating unit tests"},{"location":"repo-migration-plans/#migrating-documentation","text":"[ ] Copy all the content from the old repo's doc-src/ folder into the new repo's docs/ folder. Do not commit. [ ] Transfer the contents of the mkdocs.yml file into this new repository. Do not commit. [ ] Move off to the side all files that teach how to use the main Lurch app, because that has not yet been transferred/updated/designed in this new context. Ensure they are removed from mkdocs.yml . Do not commit. [ ] Create a gulp build process that runs mkdocs. Ensure that it works, even though the docs aren't yet updated. Commit. [ ] Proofread each page in the new site, updating any links or explanations to be accurate and up-to-date after all the recent migration changes. This should include explaining what's going on with the main app, in its limbo state. Test often as you write, using the Gulp task that builds the documentation. Commit. [ ] Update setup.litcoffee , in which I formerly commented out the section linking to the developer tutorial from the Help menu. Now you can add that link back in, to the new developer tutorial. [ ] Update the README in the lwp-example-lean repository to reference the full Lean tutorial documentation. While you're at it, check to see if that app actually uses the equation editor at all. If not, remove the eqed/ subfolder from that repository, as well as the scripts imported from it, just to simplify things.","title":"Migrating documentation"},{"location":"repo-migration-plans/#preparing-various-repos-to-be-used-in-webworkers","text":"[ ] Extend the first-order matching package with a function that checks to see if the script is being run in a WebWorker. Just check for the presence of the global WorkerGlobalScope object. If it is, then install a message listener that exposes the entire matching API to the parent window. Recall the functions for doing so, described here . [ ] Extend the tests in that module to ensure that the in-worker version works just fine when accessed by message-passing. You can get a WebWorker shim for node.js here . To do async testing in Jasmine, see the documentation on that feature here . [ ] Commit and push those changes. [ ] Extend the documentation in the mkdocs site in that repo so that it mentions the WebWorker support, showing how to use it, and linking to the relevant portions of the source code and testing spec. Commit, push. [ ] Update the minor version number and re-publish to npm. [ ] Extend the Earley Parsing package with a function that checks to see if the script is being run in a WebWorker. Just check for the presence of the global WorkerGlobalScope object. If it is, then install a message listener that exposes the entire parsing API to the parent window. Recall the functions for doing so, described here . [ ] Extend the tests in that module to ensure that the in-worker version works just fine when accessed by message-passing. You can get a WebWorker shim for node.js here . To do async testing in Jasmine, see the documentation on that feature [ ] Commit and push those changes. [ ] Extend the documentation in the mkdocs site in that repo so that it mentions the WebWorker support, showing how to use it, and linking to the relevant portions of the source code and testing spec. Commit, push. [ ] Update the minor version number and re-publish to npm.","title":"Preparing various repos to be used in WebWorkers"},{"location":"repo-migration-plans/#warning","text":"It may be best to stop here for now, until our design efforts progress far enough that we know with some certainty whether the following tasks still make sense, or at least know better how to do them correctly.","title":"Warning"},{"location":"repo-migration-plans/#handling-the-main-app","text":"[ ] Create a Gulp build process called main-app that compiles and minifies all the code in the source/main-app/ folder in the new repository, and copies all the result into a site/app/ directory, having first deleted everything in that folder. [ ] Ensure that the HTML file in that directory correctly imports the Lurch Web Platform from the parent directory ( site/ ). [ ] Ensure that the HTML app in that folder still functions, just as it does in the old repo. Commit. [ ] Once there is a main app, update the old unit tests to load the main page of that app and test themselves against it. Add those unit tests to the gulp test process.","title":"Handling the main app"},{"location":"repo-migration-plans/#adding-in-browser-testing","text":"[ ] Add PhantomJS to the package.json file of the new repository, following the lead of how this was first done in the old repository. [ ] Extend the Gulp tests task so that it successfully runs the simplest of the unit tests that require PhantomJS (probably domutils ). Commit. [ ] Extend the Gulp tests task iteratively with new unit tests that require PhantomJS, fixing errors as you proceed, committing after each.","title":"Adding in-browser testing"},{"location":"user-guide/","text":"User Guide The webLurch User Guide is for aspiring authors of Lurch documents who want to learn how to use the software. It is comprehensive, in the sense that it begins with the most basics steps, and will eventually include all details through the most advanced uses of Lurch. It is a work in progress, documenting features as they are built. Because the web version of Lurch is not yet complete, neither is this User Guide. They will grow together. Use the navigation menu at the top for Authors to access each part of the guide, or just keep clicking the \"Next\" button at the top of the page to read through it sequentially. The guide very often includes embedded live examples, which you can edit and play with (and even save their contents in your browser or in your Dropbox). They look like this: This is an example embedded Lurch document! To view an embedded demo using the full app, you have two options. Select all the content, copy it, visit the full app , and paste. ...or... From the File menu, choose Share document, copy the sharing link, paste it into your browser's URL bar, and press Enter.","title":"User Guide"},{"location":"user-guide/#user-guide","text":"The webLurch User Guide is for aspiring authors of Lurch documents who want to learn how to use the software. It is comprehensive, in the sense that it begins with the most basics steps, and will eventually include all details through the most advanced uses of Lurch. It is a work in progress, documenting features as they are built. Because the web version of Lurch is not yet complete, neither is this User Guide. They will grow together. Use the navigation menu at the top for Authors to access each part of the guide, or just keep clicking the \"Next\" button at the top of the page to read through it sequentially. The guide very often includes embedded live examples, which you can edit and play with (and even save their contents in your browser or in your Dropbox). They look like this: This is an example embedded Lurch document! To view an embedded demo using the full app, you have two options. Select all the content, copy it, visit the full app , and paste. ...or... From the File menu, choose Share document, copy the sharing link, paste it into your browser's URL bar, and press Enter.","title":"User Guide"},{"location":"user-guide/basics-1/","text":"Basics, Part 1: The editor The WYSIWYG word processor on which Lurch is built is TinyMCE . It is extremely straightforward to use, and little documentation is required. There are a few extensions to the standard configuration that Lurch adds, and those are documented on this page. Saving and loading files You can save your work (and load it again, of course) in one of two ways. Dropbox By default, the Open and Save items on the File menu expect to connect to your Dropbox account. You will be asked for permission to let Lurch access your Dropbox the first time you attempt to open or save a file. There are advantages and disadvantages to this method: Storage in the cloud is convenient, and accessible from various devices. The data is automatically backed up by Dropbox on their end. However, this requires you to have a Dropbox account and connect Lurch to it. Also, our support for Dropbox saving is currently minimal, and will save under a new filename each time. This is to be fixed in the future. Local storage You can use the Application Settings item on the File menu to switch Lurch to use your browser's \"local storage\" as a file storage area, instead of Dropbopx. As long as you continue to use the same browser from the same account on the same computer, any files you save will continue to be accessible to you. Even if you log out or reboot the computer, the files are kept, for the next time you use Lurch in that browser on that account. If you use a different browser, account, or computer, you will not see the same files. They continue to exist in the old browser, even across reboots or logins on the computer, but the new browser or computer cannot see them. The Manage Files item on the File menu lets you reorganize files into folders, within the small filesystem kept in your browser. Entering mathematics There is a button on the toolbar labeled f(x) , which allows you to insert and edit WYSIWYG mathematics. It uses MathQuill as its editor. The interface is very self-explanatory. To edit a mathematical expression you've already inserted, double-click it, and the editor will re-open. To delete a piece of typeset mathematics, simply backspace over it as you would any other piece of content, or highlight it and press delete.","title":"Basics, Part 1: The editor"},{"location":"user-guide/basics-1/#basics-part-1-the-editor","text":"The WYSIWYG word processor on which Lurch is built is TinyMCE . It is extremely straightforward to use, and little documentation is required. There are a few extensions to the standard configuration that Lurch adds, and those are documented on this page.","title":"Basics, Part 1: The editor"},{"location":"user-guide/basics-1/#saving-and-loading-files","text":"You can save your work (and load it again, of course) in one of two ways.","title":"Saving and loading files"},{"location":"user-guide/basics-1/#dropbox","text":"By default, the Open and Save items on the File menu expect to connect to your Dropbox account. You will be asked for permission to let Lurch access your Dropbox the first time you attempt to open or save a file. There are advantages and disadvantages to this method: Storage in the cloud is convenient, and accessible from various devices. The data is automatically backed up by Dropbox on their end. However, this requires you to have a Dropbox account and connect Lurch to it. Also, our support for Dropbox saving is currently minimal, and will save under a new filename each time. This is to be fixed in the future.","title":"Dropbox"},{"location":"user-guide/basics-1/#local-storage","text":"You can use the Application Settings item on the File menu to switch Lurch to use your browser's \"local storage\" as a file storage area, instead of Dropbopx. As long as you continue to use the same browser from the same account on the same computer, any files you save will continue to be accessible to you. Even if you log out or reboot the computer, the files are kept, for the next time you use Lurch in that browser on that account. If you use a different browser, account, or computer, you will not see the same files. They continue to exist in the old browser, even across reboots or logins on the computer, but the new browser or computer cannot see them. The Manage Files item on the File menu lets you reorganize files into folders, within the small filesystem kept in your browser.","title":"Local storage"},{"location":"user-guide/basics-1/#entering-mathematics","text":"There is a button on the toolbar labeled f(x) , which allows you to insert and edit WYSIWYG mathematics. It uses MathQuill as its editor. The interface is very self-explanatory. To edit a mathematical expression you've already inserted, double-click it, and the editor will re-open. To delete a piece of typeset mathematics, simply backspace over it as you would any other piece of content, or highlight it and press delete.","title":"Entering mathematics"},{"location":"user-guide/basics-2/","text":"Basics, Part 2: Expressions and canonical form What's an expression? A section of text in a Lurch document can be marked as an expression. Lurch pays attention to the content of expressions, trying to interpret them as meaningful mathematics (perhaps an algebraic equation, or a statement from logic or analysis, or perhaps the name of a theorem being cited, for example). Inserting expressions You can create expressions in your document in any of the following ways. Click the \"expression\" toolbar button to insert an empty expression at the cursor, then begin typing to fill it in. The toolbar button looks like this: [ ] Use the \"expression\" keyboard shortcut (Ctrl+[ on PCs, or Cmd+[ on Macs, which behaves exactly like the \"expression\" toolbar button) to insert an empty expression, then type. Use a LaTeX-like keyboard shortcut (such as \\[ followed by the spacebar) to open a new expression, with the cursor placed immediately inside. Select the section of the document (usually very short) that the user wishes to convert into an expression, then click the \"expression\" toolbar button so that the software will then begin treating the selection as an expression. Same as the previous, except using the keyboard shortcut instead of the toolbar button. Expression boundaries can be dragged using the mouse. This is useful when you have formed an expression, but then find that it should have enclosed a bit more or less text. Especially if you have decorated/attributed the expression (as described later in this User Guide) and do not wish to repeat that work. Dragging an expression's boundaries in a way that creates invalid nesting (one boundary inside another expression, the other not) will result in removal of the offending expression. Canonical form A few quick foundational definitions: An atomic expression is one with no other expressions inside it. A compound expression is one with at least one expression inside it. Content not inside an atomic expression is informally called flarf, to signify its lack of importance: The cannoical form of an expression is obtained by deleting all flarf. Here are some examples of these definitions. Example atomic expression: Hello. (Click to place your cursor inside it to see the bubble UI appear around it. Bubbles are shown to highlight expressions only when your cursor is inside them.) Example compound expression: an inner expression another inner expression (Try placing your cursor at various spots within the inner and outer expressions.) This text is flarf. So is this text, but this is not flarf. The canonical form of the expression in the previous paragraph is therefore but this is not flarf.","title":"Basics, Part 2: Expressions and canonical form"},{"location":"user-guide/basics-2/#basics-part-2-expressions-and-canonical-form","text":"","title":"Basics, Part 2: Expressions and canonical form"},{"location":"user-guide/basics-2/#whats-an-expression","text":"A section of text in a Lurch document can be marked as an expression. Lurch pays attention to the content of expressions, trying to interpret them as meaningful mathematics (perhaps an algebraic equation, or a statement from logic or analysis, or perhaps the name of a theorem being cited, for example).","title":"What's an expression?"},{"location":"user-guide/basics-2/#inserting-expressions","text":"You can create expressions in your document in any of the following ways. Click the \"expression\" toolbar button to insert an empty expression at the cursor, then begin typing to fill it in. The toolbar button looks like this: [ ] Use the \"expression\" keyboard shortcut (Ctrl+[ on PCs, or Cmd+[ on Macs, which behaves exactly like the \"expression\" toolbar button) to insert an empty expression, then type. Use a LaTeX-like keyboard shortcut (such as \\[ followed by the spacebar) to open a new expression, with the cursor placed immediately inside. Select the section of the document (usually very short) that the user wishes to convert into an expression, then click the \"expression\" toolbar button so that the software will then begin treating the selection as an expression. Same as the previous, except using the keyboard shortcut instead of the toolbar button. Expression boundaries can be dragged using the mouse. This is useful when you have formed an expression, but then find that it should have enclosed a bit more or less text. Especially if you have decorated/attributed the expression (as described later in this User Guide) and do not wish to repeat that work. Dragging an expression's boundaries in a way that creates invalid nesting (one boundary inside another expression, the other not) will result in removal of the offending expression.","title":"Inserting expressions"},{"location":"user-guide/basics-2/#canonical-form","text":"A few quick foundational definitions: An atomic expression is one with no other expressions inside it. A compound expression is one with at least one expression inside it. Content not inside an atomic expression is informally called flarf, to signify its lack of importance: The cannoical form of an expression is obtained by deleting all flarf. Here are some examples of these definitions. Example atomic expression: Hello. (Click to place your cursor inside it to see the bubble UI appear around it. Bubbles are shown to highlight expressions only when your cursor is inside them.) Example compound expression: an inner expression another inner expression (Try placing your cursor at various spots within the inner and outer expressions.) This text is flarf. So is this text, but this is not flarf. The canonical form of the expression in the previous paragraph is therefore but this is not flarf.","title":"Canonical form"},{"location":"user-guide/basics-3/","text":"Basics, Part 3: Connections and attributes Attributes Each expression has a set of attributes, which is a list of key-value pairs. By default, each expressions set of attributes is empty. To use one expression as an expression for another, you must connect the attribute to its target with an arrow. Do so as follows. Place your cursor in the expression that will become an attribute. Click the connections button on the toolbar (with the \u2197 icon). Click to place your cursor in the target expression. See the examples below. A connection has been created for you here: From this source to this target . Place your cursor in either expression to see the connection. Now try it yourself. Form a connection here: Make this the source, and make this the target . Keys In the examples above, all the attributes have the word \"label\" on their arrows. That is the key for the attribute, and the source expression is the attribute's value. So for example, the \"target\" expression has an attribute with key \"label\" and value \"source.\" You can change this in a few ways. To change where the key is shown: Right-click the attribute expression and choose: Move \"label\" onto attribute. This will move the word \"label\" from the arrow onto the top of the attribute bubble itself. To undo that action, right-click again and choose to move it back, or click the word \"label\" where it sits on top of the attribute bubble. To change the key: If the key is shown on the arrow, right-click the expression and choose: Change attribute key to... If the key is shown on top of the attribute bubble, click it and make the same choice. Try each of these methods in the example Lurch document above. Attributes summary You can hide an attribute inside the expression it modifies. Right-click the attribute and choose \"Hide this attribute.\" To reveal an attribute, right-click the expression into which it was hidden, and choose \"Attributes...\" A dialog will appear listing all attributes of the expression, both hidden and visible. You can hide/show them, edit the keys, edit the values of any atomic attribute values, delete attributes, and add new ones from that dialog. Here is an example of a single target with many attributes attached to it. Right-click the target and ask to see its attributes summary. (Notice the one hidden attribute!) Target expression: Abraham Lincoln Whig Some attributes attached to it: male lawyer state representative president","title":"Basics, Part 3: Connections and attributes"},{"location":"user-guide/basics-3/#basics-part-3-connections-and-attributes","text":"","title":"Basics, Part 3: Connections and attributes"},{"location":"user-guide/basics-3/#attributes","text":"Each expression has a set of attributes, which is a list of key-value pairs. By default, each expressions set of attributes is empty. To use one expression as an expression for another, you must connect the attribute to its target with an arrow. Do so as follows. Place your cursor in the expression that will become an attribute. Click the connections button on the toolbar (with the \u2197 icon). Click to place your cursor in the target expression. See the examples below. A connection has been created for you here: From this source to this target . Place your cursor in either expression to see the connection. Now try it yourself. Form a connection here: Make this the source, and make this the target .","title":"Attributes"},{"location":"user-guide/basics-3/#keys","text":"In the examples above, all the attributes have the word \"label\" on their arrows. That is the key for the attribute, and the source expression is the attribute's value. So for example, the \"target\" expression has an attribute with key \"label\" and value \"source.\" You can change this in a few ways. To change where the key is shown: Right-click the attribute expression and choose: Move \"label\" onto attribute. This will move the word \"label\" from the arrow onto the top of the attribute bubble itself. To undo that action, right-click again and choose to move it back, or click the word \"label\" where it sits on top of the attribute bubble. To change the key: If the key is shown on the arrow, right-click the expression and choose: Change attribute key to... If the key is shown on top of the attribute bubble, click it and make the same choice. Try each of these methods in the example Lurch document above.","title":"Keys"},{"location":"user-guide/basics-3/#attributes-summary","text":"You can hide an attribute inside the expression it modifies. Right-click the attribute and choose \"Hide this attribute.\" To reveal an attribute, right-click the expression into which it was hidden, and choose \"Attributes...\" A dialog will appear listing all attributes of the expression, both hidden and visible. You can hide/show them, edit the keys, edit the values of any atomic attribute values, delete attributes, and add new ones from that dialog. Here is an example of a single target with many attributes attached to it. Right-click the target and ask to see its attributes summary. (Notice the one hidden attribute!) Target expression: Abraham Lincoln Whig Some attributes attached to it: male lawyer state representative president","title":"Attributes summary"},{"location":"user-guide/basics-4/","text":"Basics, Part 4: Steps and Reasons The purpose of Lurch Lurch's purpose is that if users type mathematical reasoning into a document, the software should be able to check that reasoning, giving immediate and helpful feedback about correct and incorrect steps. The primary way this happens is that users tell Lurch the reason for each step of work they do, and Lurch looks up the reason and checks to see whether it justifies the step of work, as the user claims it does. Lurch appends an icon to the end of the step of work to show the results of validation ( \u2713 for correct, \u2716 for incorrect). Users can hover their mouse over the icon to get more feedback. How to create a step of work It's a bit early to discuss how to write a step of work, since this User Guide has not yet covered even how to write a mathematical expression in Lurch! But for now, let's pretend that Lurch understands ordinary mathematical notation, including symbols like + and = and so on. Write an expression that contains the step of work. For instance, in a proof, you might write, \"And so we see that x+1=5.\" You would mark the x+1=5 as an expression. Specify your reason as a \"reason\" attribute. That is, create a new expression, attach it as an attribute to the first, and change it from being a label to being a reason. Here is an example. Because there is no Theorem 6.1 defined here, Lurch marks the step of work invalid, but that's good -- validation is happening, and correctly! Let's pretend we're part way through a proof or computation. ...And so we can clearly see that x+1=5 , by applying Theorem 6.1 . Place your cursor in either expression to see the connection. Where do reasons come from? The step of work in the example above was marked invalid because there is no Theorem 6.1, but the user cited it as a reason as if there were. Anything you can cite as a reason we call a rule. This includes mathematical theorems, axioms from a particular mathematical field, and rules of logic. In order for a rule to be usable, it must exist either in the same document as where it's used, earlier than those steps which use it, or in a separate document that the current document cites as a source of rules it wants to use. In later parts of the User Guide, we'll see how to define our own rules in our documents. For now, let's see how to import rules another author wrote in another document. That's the topic of the next part in this tutorial .","title":"Basics, Part 4: Steps and Reasons"},{"location":"user-guide/basics-4/#basics-part-4-steps-and-reasons","text":"","title":"Basics, Part 4: Steps and Reasons"},{"location":"user-guide/basics-4/#the-purpose-of-lurch","text":"Lurch's purpose is that if users type mathematical reasoning into a document, the software should be able to check that reasoning, giving immediate and helpful feedback about correct and incorrect steps. The primary way this happens is that users tell Lurch the reason for each step of work they do, and Lurch looks up the reason and checks to see whether it justifies the step of work, as the user claims it does. Lurch appends an icon to the end of the step of work to show the results of validation ( \u2713 for correct, \u2716 for incorrect). Users can hover their mouse over the icon to get more feedback.","title":"The purpose of Lurch"},{"location":"user-guide/basics-4/#how-to-create-a-step-of-work","text":"It's a bit early to discuss how to write a step of work, since this User Guide has not yet covered even how to write a mathematical expression in Lurch! But for now, let's pretend that Lurch understands ordinary mathematical notation, including symbols like + and = and so on. Write an expression that contains the step of work. For instance, in a proof, you might write, \"And so we see that x+1=5.\" You would mark the x+1=5 as an expression. Specify your reason as a \"reason\" attribute. That is, create a new expression, attach it as an attribute to the first, and change it from being a label to being a reason. Here is an example. Because there is no Theorem 6.1 defined here, Lurch marks the step of work invalid, but that's good -- validation is happening, and correctly! Let's pretend we're part way through a proof or computation. ...And so we can clearly see that x+1=5 , by applying Theorem 6.1 . Place your cursor in either expression to see the connection.","title":"How to create a step of work"},{"location":"user-guide/basics-4/#where-do-reasons-come-from","text":"The step of work in the example above was marked invalid because there is no Theorem 6.1, but the user cited it as a reason as if there were. Anything you can cite as a reason we call a rule. This includes mathematical theorems, axioms from a particular mathematical field, and rules of logic. In order for a rule to be usable, it must exist either in the same document as where it's used, earlier than those steps which use it, or in a separate document that the current document cites as a source of rules it wants to use. In later parts of the User Guide, we'll see how to define our own rules in our documents. For now, let's see how to import rules another author wrote in another document. That's the topic of the next part in this tutorial .","title":"Where do reasons come from?"},{"location":"user-guide/basics-5/","text":"Basics, Part 5: Rules in Dependencies In the previous part , we saw how to apply a rule to a step of work, but it was unsatisfying because we didn't have access to any rules! The most common way to access rules is by telling Lurch that the document you're working on wants to use a set of rules contained in another document (often one written by an instructor). Doing so does not change the appearance of your document at all, but invisibly imports those rules so that you can use them. In such a situation, the imported document is a dependency of the current document. Documents can have zero or more dependencies. The dependency is also sometimes called a library, because it contains a set of rules that users want to reference. In the document below, a dependency has been invisibly imported for you. It contains just one rule, called \"EE\" that judges a step of work correct if it contains two E's in a row. For example, \"peek\" would be correct, but \"poke\" would not. Try applying the \"EE\" rule to the two expressions in the document. Be sure to correctly capitalize the rule name. var valid = /ee/i.test( conclusion.value ); var verb = valid ? 'contains' : 'does not contain'; return { result : valid ? 'valid' : 'invalid', message : 'The expression ' + verb + ' two successive E\\'s.' } EE yes JavaScript Justify both of these with the EE rule: peek poke","title":"Basics, Part 5: Rules in Dependencies"},{"location":"user-guide/basics-5/#basics-part-5-rules-in-dependencies","text":"In the previous part , we saw how to apply a rule to a step of work, but it was unsatisfying because we didn't have access to any rules! The most common way to access rules is by telling Lurch that the document you're working on wants to use a set of rules contained in another document (often one written by an instructor). Doing so does not change the appearance of your document at all, but invisibly imports those rules so that you can use them. In such a situation, the imported document is a dependency of the current document. Documents can have zero or more dependencies. The dependency is also sometimes called a library, because it contains a set of rules that users want to reference. In the document below, a dependency has been invisibly imported for you. It contains just one rule, called \"EE\" that judges a step of work correct if it contains two E's in a row. For example, \"peek\" would be correct, but \"poke\" would not. Try applying the \"EE\" rule to the two expressions in the document. Be sure to correctly capitalize the rule name. var valid = /ee/i.test( conclusion.value ); var verb = valid ? 'contains' : 'does not contain'; return { result : valid ? 'valid' : 'invalid', message : 'The expression ' + verb + ' two successive E\\'s.' } EE yes JavaScript Justify both of these with the EE rule: peek poke","title":"Basics, Part 5: Rules in Dependencies"},{"location":"user-guide/basics-6/","text":"Basics, Part 6: Connecting Dependencies Saving a document for use as a dependency Before you can tell Lurch about a library you want to use as a dependency in a document, you must have the library somewhere you can access it. Lurch supports (for now) two locations where you can store libraries. the local storage filesystem in your browser (which we learned about in the first part of this tutorial ) a global wiki of Lurch documents (which is not yet publicly available, but will become so as the project matures) Therefore we will do an example in which you store a library in your browser's local storage, and import it into another document from there. If you're using Dropbox for storage, temporarily switch over to using your browser's local storage, as described in the first part of this tutorial . I'll provide you a document to save. Here it is. Use the File menu in this embedded Lurch app to save the document under any name you choose, such as \"example library.lurch\". This document defines one rule, using JavaScript. Don't worry about the code for now; you just have to save the file! This silly rule judges everything to be valid. We'll name it enthusiasm . yes JavaScript return { result : 'valid', message : 'Heck yeah!' } Citing a library from a document Once you've saved the above document, you can then import it into another document. Try following these steps: In the same embedded Lurch window, above, choose File, then New. In the new document, choose File, then Document Settings. Click the button to add a file dependency. Choose the file you just saved, with the enthusiasm rule in it. Click Save to store those settings in the document. Write any expression in the new, empty document. Apply to it a reason whose contents are \"enthusiasm\" (lower case, no quotation marks). You should see the step judged correct, and if you hover your mouse over the green check mark, Lurch should give you an enthusiastic affirmation of your work.","title":"Basics, Part 6: Connecting Dependencies"},{"location":"user-guide/basics-6/#basics-part-6-connecting-dependencies","text":"","title":"Basics, Part 6: Connecting Dependencies"},{"location":"user-guide/basics-6/#saving-a-document-for-use-as-a-dependency","text":"Before you can tell Lurch about a library you want to use as a dependency in a document, you must have the library somewhere you can access it. Lurch supports (for now) two locations where you can store libraries. the local storage filesystem in your browser (which we learned about in the first part of this tutorial ) a global wiki of Lurch documents (which is not yet publicly available, but will become so as the project matures) Therefore we will do an example in which you store a library in your browser's local storage, and import it into another document from there. If you're using Dropbox for storage, temporarily switch over to using your browser's local storage, as described in the first part of this tutorial . I'll provide you a document to save. Here it is. Use the File menu in this embedded Lurch app to save the document under any name you choose, such as \"example library.lurch\". This document defines one rule, using JavaScript. Don't worry about the code for now; you just have to save the file! This silly rule judges everything to be valid. We'll name it enthusiasm . yes JavaScript return { result : 'valid', message : 'Heck yeah!' }","title":"Saving a document for use as a dependency"},{"location":"user-guide/basics-6/#citing-a-library-from-a-document","text":"Once you've saved the above document, you can then import it into another document. Try following these steps: In the same embedded Lurch window, above, choose File, then New. In the new document, choose File, then Document Settings. Click the button to add a file dependency. Choose the file you just saved, with the enthusiasm rule in it. Click Save to store those settings in the document. Write any expression in the new, empty document. Apply to it a reason whose contents are \"enthusiasm\" (lower case, no quotation marks). You should see the step judged correct, and if you hover your mouse over the green check mark, Lurch should give you an enthusiastic affirmation of your work.","title":"Citing a library from a document"},{"location":"user-guide/basics-intro/","text":"Basics: Overview The \"Basics\" section of the User Guide shows the reader how to use the Lurch editor, especially its unique features for extending a human-readable document with markings that let the computer see the logical reasoning in that document. Who should read this section? Anyone who plans to use Lurch should read this section. If you're a student who plans to use Lurch in a course, this section is a must for you. (In fact, it may be the only section of the User Guide that you need to read.) If you're new to the software, and want a tour of its capabilities, this section will provide that as well. If you hope to create new mathematical and/or logical systems within Lurch, you should start with this section, but then read on to the other sections of the User Guide as well. Use the \"Next\" button above to continue through this section of the User Guide.","title":"Basics: Overview"},{"location":"user-guide/basics-intro/#basics-overview","text":"The \"Basics\" section of the User Guide shows the reader how to use the Lurch editor, especially its unique features for extending a human-readable document with markings that let the computer see the logical reasoning in that document.","title":"Basics: Overview"},{"location":"user-guide/basics-intro/#who-should-read-this-section","text":"Anyone who plans to use Lurch should read this section. If you're a student who plans to use Lurch in a course, this section is a must for you. (In fact, it may be the only section of the User Guide that you need to read.) If you're new to the software, and want a tour of its capabilities, this section will provide that as well. If you hope to create new mathematical and/or logical systems within Lurch, you should start with this section, but then read on to the other sections of the User Guide as well. Use the \"Next\" button above to continue through this section of the User Guide.","title":"Who should read this section?"},{"location":"user-guide/tech-1/","text":"Technicalities, Part 1: Code attributes Creating code attributes To tell Lurch that an atomic expression contains computer code, give it an attribute with key \"code\" and whose value is the language in which the code is written. The only language supported at present is JavaScript. Example: The code console.log( \"Hello!\" ); is valid javascript . Editing code When you right-click an expression that has a code attribute, one of the choices on the context menu is \"Edit as code.\" Choosing it launches a code editor, and any changes you make can be saved or discarded. Saving them updates the expression in the document with the new contents of the editor. Try it now in the example above. Suppose you were to mark an expression as code by attaching a code attribute to it, then used the expression itself as an attribute to yet another expression, and finally hid the code expression within that final expression. If you examined the attributes summary dialog for that final expression, you would find an edit link next to the hidden code that would let you launch the same code-editing dialog directly from there.","title":"Technicalities, Part 1: Code attributes"},{"location":"user-guide/tech-1/#technicalities-part-1-code-attributes","text":"","title":"Technicalities, Part 1: Code attributes"},{"location":"user-guide/tech-1/#creating-code-attributes","text":"To tell Lurch that an atomic expression contains computer code, give it an attribute with key \"code\" and whose value is the language in which the code is written. The only language supported at present is JavaScript. Example: The code console.log( \"Hello!\" ); is valid javascript .","title":"Creating code attributes"},{"location":"user-guide/tech-1/#editing-code","text":"When you right-click an expression that has a code attribute, one of the choices on the context menu is \"Edit as code.\" Choosing it launches a code editor, and any changes you make can be saved or discarded. Saving them updates the expression in the document with the new contents of the editor. Try it now in the example above. Suppose you were to mark an expression as code by attaching a code attribute to it, then used the expression itself as an attribute to yet another expression, and finally hid the code expression within that final expression. If you examined the attributes summary dialog for that final expression, you would find an edit link next to the hidden code that would let you launch the same code-editing dialog directly from there.","title":"Editing code"},{"location":"user-guide/tech-2/","text":"Technicalities, Part 2: Code-based Rules A code-based rule is an atomic expression in the document containing code that can evaluate steps of a user's work, and return data about the validity of that step of work (including not only whether the step is valid, but also an explanation to the user about why). Writing a code-based rule To write a code-based rule, follow these steps. Create an atomic expression that will contain the code. Give it an attribute with key \"code\" and with value \"JavaScript\", as in the previous page of this User Guide. Give it an attribute with key \"rule\" and with any value, such as \"yes\". Give it a label, so that users can cite it. For instance, if your rule will judge simple statements of arithmetic, you might label your rule \"simple arithmetic\", so that users can say that a step of their work is true by simple arithmetic. Write code that will be used as the body of a function. The function takes two parameters, conclusion and premises . The first is an OpenMath structure about the expression to be judged. The second is an array of such structures, for each cited premise. Your code should return an object with two members: result - a string, one of \"valid\", \"invalid\", or \"intermediate\" message - a string, a short message to show to users who hover over the validation icon Example Here is a code-based rule that judges whether an atomic expression contains the letter x. If so, it calls that expression valid; if not, then invalid. (Surely, this rule is useless, except as a simple example.) I'll call this the X rule : javascript yes var hasX = /x/i.test( conclusion.value ); return { \u2003result : hasX ? 'valid' : 'invalid', \u2003message : hasX ? 'This contains an X.' : 'This contains no X.' }; Now let's try using the rule, once correctly, and once incorrectly. I think that excellent should be marked valid and awesome should be marked invalid by the X rule . Editing and debugging If you edit the document, the validation results should update in real time in response to your edits. For instance, if you change the rule citation to \"Y rule\", both expressions citing it should be marked invalid because there is no such rule. You can even edit the code of the rule; if it is in a syntactically invalid state, anything citing it will be marked invalid, with an internal rule error as the explanation. When writing the code for a rule, don't forget that you can right-click the rule and choose \"Edit as code\" to use an editor with syntax highlighting. Rules are evaluated in a separate thread without access to the DOM or the browser window, so you cannot harm the Lurch application itself. But you can use the console.log command to dump data to the console and inspect its structure. The conclusion and premise objects are both instances of the OMNode class defined in this source code file . Documentation on the class is included in the source code itself.","title":"Technicalities, Part 2: Code-based Rules"},{"location":"user-guide/tech-2/#technicalities-part-2-code-based-rules","text":"A code-based rule is an atomic expression in the document containing code that can evaluate steps of a user's work, and return data about the validity of that step of work (including not only whether the step is valid, but also an explanation to the user about why).","title":"Technicalities, Part 2: Code-based Rules"},{"location":"user-guide/tech-2/#writing-a-code-based-rule","text":"To write a code-based rule, follow these steps. Create an atomic expression that will contain the code. Give it an attribute with key \"code\" and with value \"JavaScript\", as in the previous page of this User Guide. Give it an attribute with key \"rule\" and with any value, such as \"yes\". Give it a label, so that users can cite it. For instance, if your rule will judge simple statements of arithmetic, you might label your rule \"simple arithmetic\", so that users can say that a step of their work is true by simple arithmetic. Write code that will be used as the body of a function. The function takes two parameters, conclusion and premises . The first is an OpenMath structure about the expression to be judged. The second is an array of such structures, for each cited premise. Your code should return an object with two members: result - a string, one of \"valid\", \"invalid\", or \"intermediate\" message - a string, a short message to show to users who hover over the validation icon","title":"Writing a code-based rule"},{"location":"user-guide/tech-2/#example","text":"Here is a code-based rule that judges whether an atomic expression contains the letter x. If so, it calls that expression valid; if not, then invalid. (Surely, this rule is useless, except as a simple example.) I'll call this the X rule : javascript yes var hasX = /x/i.test( conclusion.value ); return { \u2003result : hasX ? 'valid' : 'invalid', \u2003message : hasX ? 'This contains an X.' : 'This contains no X.' }; Now let's try using the rule, once correctly, and once incorrectly. I think that excellent should be marked valid and awesome should be marked invalid by the X rule .","title":"Example"},{"location":"user-guide/tech-2/#editing-and-debugging","text":"If you edit the document, the validation results should update in real time in response to your edits. For instance, if you change the rule citation to \"Y rule\", both expressions citing it should be marked invalid because there is no such rule. You can even edit the code of the rule; if it is in a syntactically invalid state, anything citing it will be marked invalid, with an internal rule error as the explanation. When writing the code for a rule, don't forget that you can right-click the rule and choose \"Edit as code\" to use an editor with syntax highlighting. Rules are evaluated in a separate thread without access to the DOM or the browser window, so you cannot harm the Lurch application itself. But you can use the console.log command to dump data to the console and inspect its structure. The conclusion and premise objects are both instances of the OMNode class defined in this source code file . Documentation on the class is included in the source code itself.","title":"Editing and debugging"},{"location":"user-guide/tech-intro/","text":"Technicalities: Overview The \"Technicalities\" section of the User Guide introduces features of Lurch that form the foundation of validation, for those who need to dig into deep customization of how Lurch processes your files. Who should read this section? Only users who are comfortable with programming and who want to know how Lurch works on a deeper level need to read this section. It will empower you to write code in Lurch documents that impact how documents are validated. Use the \"Next\" button above to continue through this section of the User Guide.","title":"Technicalities: Overview"},{"location":"user-guide/tech-intro/#technicalities-overview","text":"The \"Technicalities\" section of the User Guide introduces features of Lurch that form the foundation of validation, for those who need to dig into deep customization of how Lurch processes your files.","title":"Technicalities: Overview"},{"location":"user-guide/tech-intro/#who-should-read-this-section","text":"Only users who are comfortable with programming and who want to know how Lurch works on a deeper level need to read this section. It will empower you to write code in Lurch documents that impact how documents are validated. Use the \"Next\" button above to continue through this section of the User Guide.","title":"Who should read this section?"}]}